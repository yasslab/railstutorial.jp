<div id="top"></div>


<h1 class="chapter"><a id="sec-6" href="/chapters/modeling-users.html#top" class="heading"><span class="number">第6章</span>ユーザーのモデルを作成する</a></h1>


<p><a class="ref" href="/chapters/filling-in-the-layout.html#top">第5章</a>では、新しいユーザーを作成するためのスタブページを作ったところで終わりました (<a class="ref" href="/chapters/filling-in-the-layout.html#sec-user_signup">5.4</a>)。これから4つの章を通して、ユーザー登録ページを作っていくことにしましょう。最初の一番重要なステップは、サイトのユーザー用の<em>データモデル</em>の作成と、データを保存する手段の確保です。<a class="ref" href="/chapters/sign-up.html#top">第7章</a>では、ユーザーがサイトにユーザー登録できるようにし、ユーザープロファイルのためのページを作成します。ユーザー登録ができるようになると、次にサインイン、サインアウトもできるようにします (<a class="ref" href="/chapters/sign-in-sign-out.html#top">第8章</a>)。そして<a class="ref" href="/chapters/updating-showing-and-deleting-users.html#top">第9章</a> (<a class="ref" href="/chapters/updating-showing-and-deleting-users.html#sec-requiring_signed_in_users">9.2.1</a>) では、不正なアクセスから守る方法を学びます。まとめると、<a class="ref" href="/chapters/modeling-users.html#top">第6章</a>から<a class="ref" href="/chapters/updating-showing-and-deleting-users.html#top">第9章</a>を通して、Railsのログインと認証のシステムを一通り開発します。ご存知の方もいるとは思いますが、Railsでは既にさまざまな認証方法が利用可能です。<a class="ref" href="/chapters/modeling-users.html#sidebar-roll_your_own">囲み6.1</a>では、最初に少なくとも一度は自分で認証システムを作ってみることをお勧めする理由について説明しています。</p>

<p>この章は長いうえに、学ぶことがたくさんあります。特に、これまでデータモデリングをしたことがない人にとっては、もしかすると、これまでとは違った難しさを感じるかもしれません。しかし、この章が終わるまでには、ユーザー情報の検証、保存、取得ができる極めて強力なシステムを作成します。</p>

<div class="label" id="sidebar-roll_your_own"></div>


<div class="sidebar"><span class="title"><span class="header">囲み6.1</span></span><span class="title"><span class="description">自分で認証システムを作ってみる</span></span>
<p>事実上、すべてのアプリは何らかのログイン/認証システムを必要とします。そのため、多くのWebフレームワークではこのようなログイン/認証システムを実装するための選択肢が多数提供されています。Railsもまた例外ではありません。認証 (authentication) と認可 (authorization) のシステムの例だと、<a href="http://github.com/thoughtbot/clearance">Clearance</a>、<a href="http://github.com/binarylogic/authlogic">Authlogic</a>、<a href="http://github.com/plataformatec/devise">Devise</a>、<a href="http://railscasts.com/episodes/192-authorization-with-cancan">CanCan</a>などがあります (Railsに限らなければ<a href="http://en.wikipedia.org/wiki/OpenID">OpenID</a>や<a href="http://en.wikipedia.org/wiki/Oauth">OAuth</a>の上に構築する方法もあります)。 なぜ車輪の再発明をするのか、という質問があるのも当然です。自分でわざわざ作らなくても、いつも使える方法をただ利用するだけではいけないのでしょうか。</p>

<p>ある実践的な実験によると、多くのサイトの認証システムは膨大なカスタマイズを必要とするため、サードパーティ製品を変更して導入する場合にはシステムをゼロから作成するよりも多くの仕事を要するという結果が出ています。加えて、既成品のシステムは内部がわかりづらいことが多く、ブラックボックスになっています。自分で作成したシステムであれば、それをとてもよく理解しているはずです。さらに言えば、最近のRailsへの変更 (<a class="ref" href="/chapters/modeling-users.html#sec-adding_a_secure_password">6.3</a>) により、カスタム認証システムを容易に作成できるようになりました。最後に、<em>あえて</em>最終的にサードパーティの認証システムを導入することになったとしても、自分自身で認証システムを構築した経験があれば、サードパーティ製品を理解して変更することがずっと容易になるはずです。</p>
</div>


<p>Gitでバージョン管理を行なっているのであれば、このタイミングでユーザーをモデリングするためのトピックブランチを作成しておいてください。</p>

<div class="code"><div class="highlight"><pre><span class="gp">$</span> git checkout master
<span class="gp">$</span> git checkout -b modeling-users
</pre></div>
</div>


<p>(最初の行はmasterブランチから作業を始めることを確認するためのものです。そして、<code>modeling-users</code>トピックブランチは<code>master</code>ブランチを基に作成します。もしすでにmasterブランチにいる場合は、このコマンドを実行する必要はありません)。</p>

<div class="label" id="sec-user_model"></div>


<h2><a id="sec-6_1" href="/chapters/modeling-users.html#sec-user_model" class="heading"><span class="number">6.1</span> Userモデル</a></h2>


<p>ここから3つの章にわたる最終目標はユーザー登録ページ (<a class="ref" href="/chapters/modeling-users.html#fig-signup_mockup_preview">図6.1</a>のモックアップ) を作成することですが、今のままでは新しいユーザーの情報を受け取っても保存する場所がないので、いきなりページを作成するわけにはいきません。ユーザー登録でまず初めにやることは、それらの情報を保存するためのデータ構造を作成することです。</p>

<div class="label" id="fig-signup_mockup_preview"></div>


<div class="figure"><div class="center"><span class="graphic"><img src="/images/figures/signup_mockup_bootstrap.png" alt="signup_mockup_bootstrap" /></span></div><div class="caption"><span class="header">図6.1</span><span class="description">ユーザー登録ページのモックアップ。<a href="http://railstutorial.org/images/figures/signup_mockup_bootstrap-full.png">(拡大)</a></span></div></div>


<p>Railsでは、データモデルで使用するデフォルトのデータ構造のことを<em>モデル</em>と呼びます (<a class="ref" href="/chapters/beginning.html#sec-mvc">1.2.6</a>にあるMVCのMのことです)。Railsでは、データを永続化するデフォルトの解決策として、<em>データベース</em>を使用してデータを長期間保存します。また、データベースとやりとりするデフォルトのRailsライブラリは<em>Active Record</em>と呼ばれます<sup class="footnote" id="fnref-6_1"><a href="/chapters/modeling-users.html#fn-6_1">1</a></sup>。Active Recordは、データオブジェクトの作成/保存/検索のためのメソッドを持っています。これらのメソッドを使用するのに、<a href="http://en.wikipedia.org/wiki/Relational_database">リレーショナルデータベース</a>で使うSQL (Structured Query Language)<sup class="footnote" id="fnref-6_2"><a href="/chapters/modeling-users.html#fn-6_2">2</a></sup>を意識する必要はありません。さらに、Railsには<em>マイグレーション</em>という機能があります。データの定義をRubyで記述することができ、SQLのDDL (Data Definition Language)を新たに学ぶ必要がありません。Railsは、データストアの詳細からほぼ完全に私たちを切り離してくれます。本書では、SQLiteを開発 (development) 環境で使い、またPostgreSQLを (Herokuでの) 開発環境で使います (<a class="ref" href="/chapters/beginning.html#sec-deploying">1.4</a>)。Railsは、本番 (production) アプリケーションですら、データの保存方法の詳細についてほとんど考える必要がないくらいよくできています。</p>

<div class="label" id="sec-database_migrations"></div>


<h3><a id="sec-6_1_1" href="/chapters/modeling-users.html#sec-database_migrations" class="heading"><span class="number">6.1.1</span>データベースの移行</a></h3>


<p><a class="ref" href="/chapters/rails-flavored-ruby.html#sec-a_user_class">4.4.5</a>で扱ったカスタムビルドクラスの<code>User</code>を思い出してください。このクラスは、<code>name</code>と<code>email</code>を属性に持つユーザーオブジェクトでした。このクラスは役に立つ例として提供されましたが、Railsにとってきわめて重要な部分である<em>永続性</em>という要素が欠けていました。RailsコンソールでUserクラスのオブジェクトを作っても、コンソールからexitするとそのオブジェクトはすぐに消えてしまいました。この節での目的は、簡単に消えることのないユーザーのモデルを構築することです。</p>

<p><a class="ref" href="/chapters/rails-flavored-ruby.html#sec-a_user_class">4.4.5</a>のユーザークラスと同様に、<code>name</code>と<code>email</code>の2つの属性からなるユーザーをモデリングするところから始めましょう。後者のemailを一意のユーザー名として使用します<sup class="footnote" id="fnref-6_3"><a href="/chapters/modeling-users.html#fn-6_3">3</a></sup> (パスワードのための属性は<a class="ref" href="/chapters/modeling-users.html#sec-adding_a_secure_password">6.3</a>で扱います) 。<a class="ref" href="/chapters/rails-flavored-ruby.html#code-example_user">リスト4.9</a>では、以下のようにRubyの<code>attr_accessor</code>メソッドを使用しました。</p>

<div class="code"><div class="highlight"><pre><span class="k">class</span> <span class="nc">User</span>
  <span class="kp">attr_accessor</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">:email</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
<span class="k">end</span>
</pre></div>
</div>


<p>それとは対照的に、Railsでユーザーをモデリングするときは、属性を明示的に識別する必要がありません。上で簡潔に述べたように、Railsはデータを保存する際にデフォルトでリレーショナルデータベースを使用します。リレーショナルデータベースは、データ<em>行</em>で構成される<em>テーブル</em>からなり、各行はデータ属性の<em>カラム</em> (列) を持ちます。たとえば、nameとemailを持つユーザーを保存するのであれば、<code>name</code>と<code>email</code>のカラムを持つ<code>users</code>テーブルを作成します (各行はひとりのユーザーを表します)。カラムをこのように名付けることによって、Active RecordでUserオブジェクトの属性を利用できるようになります。</p>

<p>それでは実際どのように動作するのか見てみましょう (ここまでの説明が抽象的でわかりにくいかもしれませんが、少しだけご辛抱願います。<a class="ref" href="/chapters/modeling-users.html#sec-creating_user_objects">6.1.3</a>から使用しているコンソールの例と、<a class="ref" href="/chapters/modeling-users.html#fig-sqlite_database_browser">図6.3</a>と<a class="ref" href="/chapters/modeling-users.html#fig-sqlite_user_row">図6.6</a>にあるデータベースブラウザのスクリーンショットが理解を助けてくれるでしょう)。<a class="ref" href="/chapters/filling-in-the-layout.html#code-generate_users_controller">リスト5.28</a>で、ユーザーコントローラ (と<code>new</code>アクション) を作ったときに使った以下のコマンドを思い出してみてください。</p>

<div class="code"><div class="highlight"><pre><span class="gp">$</span> rails generate controller Users new --no-test-framework
</pre></div>
</div>


<p>上のコマンドはコントローラを作成しましたが、同様にモデルを作成するコマンドとして、<code>generate model</code>があります。<code>name</code>と<code>email</code>の2つの属性を持つUserモデルを作成するコマンドを<a class="ref" href="/chapters/modeling-users.html#code-generate_user_model">リスト6.1</a>に示します。</p>

<div class="label" id="code-generate_user_model"></div>


<div class="codelisting">
<div class="listing"><span class="header">リスト6.1</span> <span class="description">Userモデルの作成。</span> </div>
<div class="code"><div class="highlight"><pre>$ rails generate model User name:string email:string
      invoke  active_record
      create    db/migrate/[timestamp]_create_users.rb
      create    app/models/user.rb
      invoke    rspec
      create      spec/models/user_spec.rb
</pre></div>
</div></div>


<p>(コントローラ名には複数形を使い、モデル名には単数形を用いるという慣習を頭に入れておいてください。コントローラはUsersでモデルはUserです)。<code>name:string</code>や<code>email:string</code>オプションのパラメータを渡すことによって、データベースで使用したい2つの属性をRailsに伝えます。このときに、これらの属性の型情報も一緒に渡します (この場合は<code>string</code>)。<a class="ref" href="/chapters/static-pages.html#code-generating_pages">リスト3.4</a>や<a class="ref" href="/chapters/filling-in-the-layout.html#code-generate_users_controller">リスト5.28</a>でアクション名を使用して生成した例と比較してみてください。</p>

<p><a class="ref" href="/chapters/modeling-users.html#code-generate_user_model">リスト6.1</a>にある<code>generate</code>コマンドの結果のひとつとして、<em>マイグレーション</em>と呼ばれる新しいファイルが生成されます。マイグレーションは、データベースの構造をインクリメンタルに変更する手段を提供します。それにより、要求が変更された場合にデータモデルを適合させることができます。このUserモデルの例の場合、マイグレーションはモデル生成スクリプトによって自動的に作られました。<a class="ref" href="/chapters/modeling-users.html#code-users_migration">リスト6.2</a>にあるように<code>name</code>と<code>email</code>の2つのカラムを持つ<code>users</code>テーブルを作成します (<a class="ref" href="/chapters/modeling-users.html#sec-uniqueness_validation">6.2.5</a>と<a class="ref" href="/chapters/modeling-users.html#sec-adding_a_secure_password">6.3</a>で、マイグレーションを一から手動で作成する方法について説明します)。</p>

<div class="label" id="code-users_migration"></div>


<div class="codelisting">
<div class="listing"><span class="header">リスト6.2</span> <span class="description">(<code>users</code>テーブルを作るための) Userモデルのマイグレーション。</span><br /><span class="description"> <code>db/migrate/[timestamp]_create_users.rb</code></span> </div>
<div class="code"><div class="highlight"><pre><span class="k">class</span> <span class="nc">CreateUsers</span> <span class="o">&lt;</span> <span class="ss">ActiveRecord::Migration</span>
  <span class="k">def</span> <span class="nf">change</span>
    <span class="n">create_table</span> <span class="ss">:users</span> <span class="k">do</span> <span class="o">|</span><span class="n">t</span><span class="o">|</span>
      <span class="n">t</span><span class="o">.</span><span class="n">string</span> <span class="ss">:name</span>
      <span class="n">t</span><span class="o">.</span><span class="n">string</span> <span class="ss">:email</span>

      <span class="n">t</span><span class="o">.</span><span class="n">timestamps</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div></div>


<p>マイグレーションファイル名の先頭には、それが生成された時間の<em>タイムスタンプ</em>が追加されます。以前はインクリメンタルな整数が追加されていましたが、複数の開発者によるチームでは、複数のプログラマが同じ整数を持つマイグレーションを生成してしまい、コンフリクトを引き起こしていました。現在のタイムスタンプによる方法であれば、まったく同時にマイグレーションが生成されるという通常ではありえないことが起きない限り、そのようなコンフリクトを避けることができます。</p>

<p>マイグレーション自体は、データベースに与える変更を定義した<code>change</code>メソッドの集まりです。<a class="ref" href="/chapters/modeling-users.html#code-users_migration">リスト6.2</a>の場合、<code>change</code>メソッドは<code>create_table</code>というRailsのメソッドを呼び、ユーザーを保存するための<em>テーブル</em>をデータベースに作成します。<code>create_table</code>メソッドはブロック変数を1つ持つブロック (<a class="ref" href="/chapters/rails-flavored-ruby.html#sec-blocks">4.3.2</a>) を受け取ります。ここでは (“table”の頭文字を取って) <code>t</code>です。そのブロックの中で、<code>create_table</code>メソッドは<code>t</code>オブジェクトを使って、今度は<code>name</code>と<code>email</code>カラムをデータベースに作成します。型はいずれも<code>string</code>です<sup class="footnote" id="fnref-6_4"><a href="/chapters/modeling-users.html#fn-6_4">4</a></sup>。モデル名は単数形 (User) ですが、テーブル名は複数形 (<code>users</code>) です。これはRailsで用いられる言葉の慣習を反映しています。モデルはひとりのユーザーを表すのに対し、データベースのテーブルは複数のユーザーから構成されます。ブロックの最後の行<code>t.timestamps</code>は特別なコマンドで、<code>created_at</code>と<code>updated_at</code>という2つの「<em>マジックカラム</em>」を作成します。これらは、あるユーザーが作成または更新されたときに、その時刻を自動的に記録するタイムスタンプです (このマジックカラムの使用例を<a class="ref" href="/chapters/modeling-users.html#sec-creating_user_objects">6.1.3</a>から具体的に見ていきます)。 このマイグレーションで作られる完全なデータモデルを<a class="ref" href="/chapters/modeling-users.html#fig-user_model_initial">図6.2</a>に示します。</p>

<div class="label" id="fig-user_model_initial"></div>


<div class="figure"><div class="center"><span class="graphic"><img src="/images/figures/user_model_initial.png" alt="user_model_initial" /></span></div><div class="caption"><span class="header">図6.2</span><span class="description"><a class="ref" href="/chapters/modeling-users.html#code-users_migration">リスト6.2</a>によるユーザーデータモデル</span></div></div>


<p>マイグレーションは、以下のように<code>rake</code>コマンド (<a class="ref" href="/chapters/a-demo-app.html#sidebar-rake">囲み2.1</a>) を使って実行することができます。これを“マイグレーションの適用 (migrating up)”と呼びます。</p>

<div class="code"><div class="highlight"><pre><span class="gp">$</span> bundle <span class="nb">exec </span>rake db:migrate
</pre></div>
</div>


<p>(<a class="ref" href="/chapters/a-demo-app.html#sec-demo_users_resource">2.2</a>で、一度このコマンドを実行したことを思い出してみてください) 。初めて<code>db:migrate</code>が実行されると、<code>db/development.sqlite3</code>という名前のファイルが生成されます。これは<a href="http://sqlite.org/">SQLite</a><sup class="footnote" id="fnref-6_5"><a href="/chapters/modeling-users.html#fn-6_5">5</a></sup>データベースです。<code>db/development.sqlite3</code>ファイルを開くための<a href="http://sourceforge.net/projects/sqlitebrowser/">SQLite Database Browser</a>という素晴らしいツールを使って、データベースの構造を詳しく参照することができます (<a class="ref" href="/chapters/modeling-users.html#fig-sqlite_database_browser">図6.3</a>)。<a class="ref" href="/chapters/modeling-users.html#fig-user_model_initial">図6.2</a>の表と比べてみてください。<a class="ref" href="/chapters/modeling-users.html#fig-sqlite_database_browser">図6.3</a>の中に<code>id</code>というマイグレーションのときに説明されなかったカラムの存在に気づいたかもしれません。<a class="ref" href="/chapters/a-demo-app.html#sec-demo_users_resource">2.2</a>で簡単に説明したとおり、このカラムは自動的に作成され、Railsが各行を一意に識別するために使用します。</p>

<div class="label" id="fig-sqlite_database_browser"></div>


<div class="figure"><div class="center"><span class="graphic"><img src="/images/figures/sqlite_database_browser.png" alt="sqlite_database_browser" /></span></div><div class="caption"><span class="header">図6.3</span><span class="description"><a href="http://sqlitebrowser.sourceforge.net/">SQLite Database Browser</a>と作成した<code>users</code>テーブル。<a href="http://railstutorial.org/images/figures/sqlite_database_browser-full.png">(拡大)</a></span></div></div>


<p><em>Railsチュートリアル</em>で使用されているものすべてを含め、ほとんどのマイグレーションが<em>可逆</em>です。これは、<code>db:rollback</code>というRakeタスクで変更を取り消せることを意味します。これを“マイグレーションの取り消し (migrate down)”と呼びます。</p>

<div class="code"><div class="highlight"><pre><span class="gp">$</span> bundle <span class="nb">exec </span>rake db:rollback
</pre></div>
</div>


<p>(<a class="ref" href="/chapters/static-pages.html#sidebar-undoing_things">囲み3.1</a>では、マイグレーションを元に戻すための便利なテクニックを他にも紹介しています)。上のコマンドでは、データベースからusersテーブルを削除するために<code>drop_table</code>コマンドを内部で呼び出しています。これがうまくいくのは、<code>change</code>メソッドは<code>drop_table</code>が<code>create_table</code>の逆であることを知っているからです。つまり、ロールバック用の逆方向マイグレーションを簡単に導くことができるのです。あるカラムを削除するような不可逆なマイグレーションの場合は、<code>change</code>メソッドの代わりに、<code>up</code>と<code>down</code>のメソッドを別々に定義する必要があります。詳細については、「<a href="http://guides.rubyonrails.org/migrations.html">Rails Guidesのマイグレーション</a> (英語)」を参照してください。</p>

<p>もし今の時点でデータベースのロールバックを実行していた場合は、先に進む前にもう一度以下のようにマイグレーションを適用して元に戻してください。</p>

<div class="code"><div class="highlight"><pre><span class="gp">$</span> bundle <span class="nb">exec </span>rake db:migrate
</pre></div>
</div>




<div class="label" id="sec-the_model_file"></div>


<h3><a id="sec-6_1_2" href="/chapters/modeling-users.html#sec-the_model_file" class="heading"><span class="number">6.1.2</span>modelファイル</a></h3>


<p>これまで、<a class="ref" href="/chapters/modeling-users.html#code-generate_user_model">リスト6.1</a>のUserモデルの作成によってどのように (<a class="ref" href="/chapters/modeling-users.html#code-users_migration">リスト6.2</a>) のマイグレーションファイルが作成されるかを見てきました。そして<a class="ref" href="/chapters/modeling-users.html#fig-sqlite_database_browser">図6.3</a>でこのマイグレーションを実行した結果を見ました。<code>development.sqlite3</code>という名のファイルを<code>users</code>テーブルを作成することで更新し、<code>id</code>、<code>name</code>、<code>email</code>、<code>created_at</code>、<code>updated_at</code>を作成しました。<a class="ref" href="/chapters/modeling-users.html#code-generate_user_model">リスト6.1</a>はモデル自体も作成しました。この節では、以後これらを理解することに専念します。</p>

<p>まず、<code>app/models/</code>ディレクトリにある<code>user.rb</code>ファイルに書かれたUserモデルのコードを見てみましょう。これは控えめに言ってもとてもよくまとまっています (<a class="ref" href="/chapters/modeling-users.html#code-raw_user_model">リスト6.3</a>) (<em>注</em>: もしRails 3.2.2か、それ以前のバージョンを使っている場合は<code>attr_accessible</code>の行は存在しません。その場合は<a class="ref" href="/chapters/modeling-users.html#sec-accessible_attributes">6.1.2.2</a>で追加する必要があります)。</p>

<div class="label" id="code-raw_user_model"></div>


<div class="codelisting">
<div class="listing"><span class="header">リスト6.3</span> <span class="description">新しいUserモデル。</span><br /><span class="description"> <code>app/models/user.rb</code></span> </div>
<div class="code"><div class="highlight"><pre><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="ss">ActiveRecord::Base</span>
  <span class="n">attr_accessible</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">:email</span>
<span class="k">end</span>
</pre></div>
</div></div>


<p><a class="ref" href="/chapters/rails-flavored-ruby.html#sec-a_class_of_our_own">4.4.2</a>で行ったことを思い出してみましょう。<code>class User &lt; ActiveRecord::Base</code>という構文で、<code>User</code>クラスは<code>ActiveRecord::Base</code>を<em>継承するので</em>、Userモデルは自動的に<code>ActiveRecord::Base</code>クラスのすべての機能を持ちます。もちろん、この継承の知識は、<code>ActiveRecord::Base</code>に含まれるメソッドなどについて知らなければ何の役にも立ちません。それらの知識の一部についてはこれからご説明します。ただしその前に、完了させておかなければならない作業が2つあります。</p>

<div class="label" id="sec-model_annotation"></div>


<h4><a id="sec-6_1_2_1" href="/chapters/modeling-users.html#sec-model_annotation" class="heading">モデル注釈</a></h4>


<p>必須というわけではありませんが、<code>annotate</code> gem (<a class="ref" href="/chapters/modeling-users.html#code-gemfile_annotate">リスト6.4</a>) を使ってRailsのモデルに<em>注釈を追加する</em>ようにしておくと便利なことがあります。</p>

<div class="label" id="code-gemfile_annotate"></div>


<div class="codelisting">
<div class="listing"><span class="header">リスト6.4</span> <span class="description"><code>Gemfile</code>に<code>annotate</code> gemを追加する。</span> </div>
<div class="code"><div class="highlight"><pre><span class="n">source</span> <span class="s1">&#39;https://rubygems.org&#39;</span>
<span class="o">.</span>
<span class="o">.</span>
<span class="o">.</span>
<span class="n">group</span> <span class="ss">:development</span><span class="p">,</span> <span class="ss">:test</span> <span class="k">do</span>
  <span class="n">gem</span> <span class="s1">&#39;sqlite3&#39;</span><span class="p">,</span> <span class="s1">&#39;1.3.5&#39;</span>
  <span class="n">gem</span> <span class="s1">&#39;rspec-rails&#39;</span><span class="p">,</span> <span class="s1">&#39;2.11.0&#39;</span>
<span class="k">end</span>


<span class="n">group</span> <span class="ss">:development</span> <span class="k">do</span>
  <span class="n">gem</span> <span class="s1">&#39;annotate&#39;</span><span class="p">,</span> <span class="s1">&#39;2.5.0&#39;</span>
<span class="k">end</span>

<span class="n">group</span> <span class="ss">:test</span> <span class="k">do</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
<span class="k">end</span>
</pre></div>
</div></div>


<p>(この注釈機能は本番アプリでは不要なので、<code>annotate</code> gemは<code>group :development</code>ブロックの中に書きます (<code>group :test</code>に書いたときと同じ要領です))。次に<code>bundle install</code>を実行してインストールします。</p>

<div class="code"><div class="highlight"><pre><span class="gp">$</span> bundle install
</pre></div>
</div>


<p>これにより<code>annotate</code>コマンドが使えるようになります。これを実行すると、モデルファイルにデータモデルを含んだコメントが追加されます。</p>

<div class="code"><div class="highlight"><pre><span class="gp">$</span> bundle <span class="nb">exec </span>annotate
<span class="go">Annotated (1): User</span>
</pre></div>
</div>


<p>実行結果を<a class="ref" href="/chapters/modeling-users.html#code-annotated_user_model">リスト6.5</a>に示します。</p>

<div class="label" id="code-annotated_user_model"></div>


<div class="codelisting">
<div class="listing"><span class="header">リスト6.5</span> <span class="description">注釈が追加されたUserモデル。</span><br /><span class="description"> <code>app/models/user.rb</code></span> </div>
<div class="code"><div class="highlight"><pre><span class="c1"># == Schema Information</span>
<span class="c1">#</span>
<span class="c1"># Table name: users</span>
<span class="c1">#</span>
<span class="c1">#  id         :integer         not null, primary key</span>
<span class="c1">#  name       :string(255)</span>
<span class="c1">#  email      :string(255)</span>
<span class="c1">#  created_at :datetime</span>
<span class="c1">#  updated_at :datetime</span>
<span class="c1">#</span>

<span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="ss">ActiveRecord::Base</span>
  <span class="n">attr_accessible</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">:email</span>
<span class="k">end</span>
</pre></div>
</div></div>


<p>データモデルをモデルファイルの中にコメントとして残しておくと、モデルにどんな属性があるかを楽に思い出せます。なお簡潔さのため、本書で今後使用するコードにはこの注釈を付けません (もし注釈を最新の状態に保ちたいのであれば、データモデルが変わるたびに<code>annotate</code>を実行しなければならないことにご注意ください)。</p>

<div class="label" id="sec-accessible_attributes"></div>


<h4><a id="sec-6_1_2_2" href="/chapters/modeling-users.html#sec-accessible_attributes" class="heading">アクセス可能な属性</a></h4>


<p>それではもう一度Userモデルに戻りましょう。<code>attr_accessible</code>の行にご注目ください (<a class="ref" href="/chapters/modeling-users.html#code-attr_accessible">リスト6.6</a>)。この行は、モデルのどの属性を<em>アクセス可能</em>にするかをRailsに伝えます。たとえば、外部のユーザー (Webブラウザを使用してリクエストを送信するユーザーなど) が変更してもよい属性を指定します。</p>

<div class="label" id="code-attr_accessible"></div>


<div class="codelisting">
<div class="listing"><span class="header">リスト6.6</span> <span class="description"><code>name</code>と<code>email</code>属性をアクセス可能にする。</span><br /><span class="description"> <code>app/models/user.rb</code></span> </div>
<div class="code"><div class="highlight"><pre><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="ss">ActiveRecord::Base</span>
  <span class="n">attr_accessible</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">:email</span>
<span class="k">end</span>
</pre></div>
</div></div>


<p><a class="ref" href="/chapters/modeling-users.html#code-attr_accessible">リスト6.6</a>のコードの動作は若干わかりにくいところがあるので注意が必要です。モデルにattr_accessibleを書かない場合は、デフォルトで「モデルの<em>すべての</em>属性がアクセス可能」になります。<a class="ref" href="/chapters/modeling-users.html#code-attr_accessible">リスト6.6</a>は、<code>name</code>と<code>email</code>属性が外部のユーザーからアクセス可能であることを指定すると同時に、「 明示的に指定された<code>name</code>と<code>email</code>属性<em>以外の</em>属性はすべてアクセス不可能とする」ことを暗黙に指定します。この動作を理解することが重要な理由については、<a class="ref" href="/chapters/updating-showing-and-deleting-users.html#top">第9章</a>で説明します。<em>マスアサインメント</em>の脆弱性から守るためには、<code>attr_accessible</code>を必ず使用することが重要です。マスアサインメント脆弱性は非常によくあるセキュリティ問題で、多くのRailsアプリケーションで重大なセキュリティホールの原因となりました。</p>

<div class="label" id="sec-creating_user_objects"></div>


<h3><a id="sec-6_1_3" href="/chapters/modeling-users.html#sec-creating_user_objects" class="heading"><span class="number">6.1.3</span>ユーザーオブジェクトを作成する</a></h3>


<p>準備が完了しましたので、いよいよActive Recordについて学ぶことにしましょう。先ほど作成したUserモデルを使用します。<a class="ref" href="/chapters/rails-flavored-ruby.html#top">第4章</a>と同じく、Railsコンソールを使います。(この時点では) データベースを変更したくないので、コンソールを<em>サンドボックス</em>モードで起動します。</p>

<div class="code"><div class="highlight"><pre><span class="go">$ rails console --sandbox</span>
<span class="go">Loading development environment in sandbox</span>
<span class="go">Any modifications you make will be rolled back on exit</span>
<span class="gp">&gt;&gt; </span>
</pre></div>
</div>


<p>&quot;Any modifications you make will be rolled back on exit&quot;  (ここで行ったすべての変更は終了時にロールバックされます) というメッセージにわかりやすく示されているように、コンソールをサンドボックスで起動すると、そのセッションで行ったデータベースへの変更をコンソールの終了時にすべて “ロールバック” (取り消し) してくれます。</p>

<p><a class="ref" href="/chapters/rails-flavored-ruby.html#sec-a_user_class">4.4.5</a>のコンソールセッションでは<code>User.new</code>で新しいユーザーオブジェクトを生成しましたが、<a class="ref" href="/chapters/rails-flavored-ruby.html#code-example_user">リスト4.9</a>のexample_userファイルを明示的にrequireするまでこのオブジェクトにはアクセスできませんでした。しかし、モデルを使うと状況は異なります。<a class="ref" href="/chapters/rails-flavored-ruby.html#sec-a_controller_class">4.4.4</a>で見たように、Railsコンソールは起動時にRailsの環境を自動的に読み込み、その環境にはモデルも含まれます。つまり、新しいユーザーオブジェクトを作成するときに余分な作業を行わずに済むということです。</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="no">User</span><span class="o">.</span><span class="n">new</span>
<span class="go">=&gt; #&lt;User id: nil, name: nil, email: nil, created_at: nil, updated_at: nil&gt;</span>
</pre></div>
</div>


<p>コンソールでは上のように、ユーザーオブジェクトはデフォルトの表現として、<a class="ref" href="/chapters/modeling-users.html#fig-user_model_initial">図6.2</a>と<a class="ref" href="/chapters/modeling-users.html#code-annotated_user_model">リスト6.5</a>と同じ属性を出力していることがわかります。</p>

<p><code>User.new</code>を引数なしで呼んだ場合は、すべての属性が<code>nil</code>のオブジェクトを返します。<a class="ref" href="/chapters/rails-flavored-ruby.html#sec-a_user_class">4.4.5</a>では、オブジェクトの属性を設定する<em>初期化ハッシュ (hash) </em>を引数に取るために、Userクラスの例 (user_example.rb) を設計しました。この設計にはActive Recordが使用されており、ここでも同じ方法で初期化できます。</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="n">user</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="nb">name</span><span class="p">:</span> <span class="s2">&quot;Michael Hartl&quot;</span><span class="p">,</span> <span class="ss">email:</span> <span class="s2">&quot;mhartl@example.com&quot;</span><span class="p">)</span>
<span class="go">=&gt; #&lt;User id: nil, name: &quot;Michael Hartl&quot;, email: &quot;mhartl@example.com&quot;,</span>
<span class="go">created_at: nil, updated_at: nil&gt;</span>
</pre></div>
</div>


<p>上のように、nameとemail属性が期待どおり設定されていることがわかります。</p>

<p>開発ログをtailしたまま上を実行していた場合、実行後に新しい行が何も表示されないことに気付いた方もいると思います。これは、<code>User.new</code>を実行しても単にRubyオブジェクトをメモリ上に作成するだけで、データベースにはアクセスしないためです。このユーザーオブジェクトをデータベースに実際に保存するには、<code>user</code>変数に対して<code>save</code>メソッドを呼びます。</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="n">user</span><span class="o">.</span><span class="n">save</span>
<span class="go">=&gt; true</span>
</pre></div>
</div>


<p><code>save</code>メソッドは、成功すれば<code>true</code>を、失敗すれば<code>false</code>を返します (現状では、保存はすべて成功するはずです。失敗する場合については<a class="ref" href="/chapters/modeling-users.html#sec-user_validations">6.2</a>で説明します)。 保存すると、SQLコマンドの<code>INSERT INTO &quot;users&quot;</code>という行が開発ログに追加出力されることがすぐに確認できます。Active Recordによって多数のメソッドが提供されているので、本書では生のSQLを書く必要がありません。従って、本書ではこれ以降はSQLコマンドについての説明を省略します。ただしそれでも、開発ログを監視することによってSQLについて多くのことを学ぶことができるでしょう。</p>

<p>作成した時点でのユーザーオブジェクトは、<code>id</code>属性、マジックカラムである<code>created_at</code>属性と<code>updated_at</code>属性の値がいずれも<code>nil</code>であったことを思い出してください。<code>save</code>メソッドを実行した後に何が変更されたのかを確認してみましょう。</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="n">user</span>
<span class="go">=&gt; #&lt;User id: 1, name: &quot;Michael Hartl&quot;, email: &quot;mhartl@example.com&quot;,</span>
<span class="go">created_at: &quot;2011-12-05 00:57:46&quot;, updated_at: &quot;2011-12-05 00:57:46&quot;&gt;</span>
</pre></div>
</div>


<p><code>id</code>には<code>1</code>という値が代入され、一方でマジックカラムには現在の日時が代入されているのがわかります<sup class="footnote" id="fnref-6_6"><a href="/chapters/modeling-users.html#fn-6_6">6</a></sup>。現在、作成と更新のタイムスタンプは同一ですが、<a class="ref" href="/chapters/modeling-users.html#sec-updating_user_objects">6.1.5</a>では異なる値になります。</p>

<p><a class="ref" href="/chapters/rails-flavored-ruby.html#sec-a_user_class">4.4.5</a>のUserクラスと同様に、Userモデルのインスタンスはドット記法を用いてその属性にアクセスすることができます<sup class="footnote" id="fnref-6_7"><a href="/chapters/modeling-users.html#fn-6_7">7</a></sup>。</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="n">user</span><span class="o">.</span><span class="n">name</span>
<span class="go">Michael Hartl (マイケル・ハートル)</span>
<span class="gp">&gt;&gt; </span><span class="n">user</span><span class="o">.</span><span class="n">email</span>
<span class="go">=&gt; &quot;mhartl@example.com&quot;</span>
<span class="gp">&gt;&gt; </span><span class="n">user</span><span class="o">.</span><span class="n">updated_at</span>
<span class="go">=&gt; Tue, 05 Dec 2011 00:57:46 UTC +00:00</span>
</pre></div>
</div>


<p>詳細は<a class="ref" href="/chapters/sign-up.html#top">第7章</a>でも説明しますが、上で見たようにモデルの生成と保存を2つのステップに分けておくと何かと便利です。しかし、Active Recordでは<code>User.create</code>でモデルの生成と保存を同時に行う方法も提供されています。</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="no">User</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="nb">name</span><span class="p">:</span> <span class="s2">&quot;A Nother&quot;</span><span class="p">,</span> <span class="ss">email:</span> <span class="s2">&quot;another@example.org&quot;</span><span class="p">)</span>
<span class="go">#&lt;User id: 2, name: &quot;A Nother&quot;, email: &quot;another@example.org&quot;, created_at:</span>
<span class="go">&quot;2011-12-05 01:05:24&quot;, updated_at: &quot;2011-12-05 01:05:24&quot;&gt;</span>
<span class="gp">&gt;&gt; </span><span class="n">foo</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="nb">name</span><span class="p">:</span> <span class="s2">&quot;Foo&quot;</span><span class="p">,</span> <span class="ss">email:</span> <span class="s2">&quot;foo@bar.com&quot;</span><span class="p">)</span>
<span class="go">#&lt;User id: 3, name: &quot;Foo&quot;, email: &quot;foo@bar.com&quot;, created_at: &quot;2011-12-05</span>
<span class="go">01:05:42&quot;, updated_at: &quot;2011-12-05 01:05:42&quot;&gt;</span>
</pre></div>
</div>


<p><code>User.create</code>は、<code>true</code>か<code>false</code>を返す代わりに、ユーザーオブジェクト自身を返すことにご注目ください。返されたユーザーオブジェクトは (上の2つ目のコマンドにある<code>foo</code>のように) 変数に代入することもできます。</p>

<p><code>destroy</code>は<code>create</code>の逆です。</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="n">foo</span><span class="o">.</span><span class="n">destroy</span>
<span class="go">=&gt; #&lt;User id: 3, name: &quot;Foo&quot;, email: &quot;foo@bar.com&quot;, created_at: &quot;2011-12-05</span>
<span class="go">01:05:42&quot;, updated_at: &quot;2011-12-05 01:05:42&quot;&gt;</span>
</pre></div>
</div>


<p>奇妙なことに、<code>destroy</code>は<code>create</code>と同じようにそのオブジェクト自身を返しますが、その返り値を使用しても、もう一度<code>destroy</code>を呼ぶことはできません。そして、おそらくさらに奇妙なことに、<code>destroy</code>されたオブジェクトは以下のようにまだメモリ上に残っています。</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="n">foo</span>
<span class="go">=&gt; #&lt;User id: 3, name: &quot;Foo&quot;, email: &quot;foo@bar.com&quot;, created_at: &quot;2011-12-05</span>
<span class="go">01:05:42&quot;, updated_at: &quot;2011-12-05 01:05:42&quot;&gt;</span>
</pre></div>
</div>


<p>オブジェクトが本当に削除されたかどうかをどのようにして知ればよいでしょうか。そして、保存して削除されていないオブジェクトの場合、どうやってデータベースからユーザーを取得するのでしょうか。いよいよActive Recordでユーザーオブジェクトを検索する方法を学ぶときが来ました。</p>

<div class="label" id="sec-finding_user_objects"></div>


<h3><a id="sec-6_1_4" href="/chapters/modeling-users.html#sec-finding_user_objects" class="heading"><span class="number">6.1.4</span>ユーザーオブジェクトを検索する</a></h3>


<p>Active Recordには、オブジェクトを検索するための方法がいくつもあります。これらの機能を使用して、過去に作成した最初のユーザーを探してみましょう。また、3番目のユーザー (<code>foo</code>) が削除されていることを確認しましょう。まずは存在するユーザーから探してみましょう。</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="no">User</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">=&gt; #&lt;User id: 1, name: &quot;Michael Hartl&quot;, email: &quot;mhartl@example.com&quot;,</span>
<span class="go">created_at: &quot;2011-12-05 00:57:46&quot;, updated_at: &quot;2011-12-05 00:57:46&quot;&gt;</span>
</pre></div>
</div>


<p>ここでは、<code>User.find</code>にユーザーのidを渡しています。その結果、Active Recordはそのidのユーザーを返します。</p>

<p>次に、<code>id</code>=<code>3</code>のユーザーがまだデータベースに存在するかどうかを確認してみましょう。</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="no">User</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">ActiveRecord::RecordNotFound: Couldn&#39;t find User with ID=3</span>
</pre></div>
</div>


<p><a class="ref" href="/chapters/modeling-users.html#sec-creating_user_objects">6.1.3</a>で3番目のユーザーを削除したので、Active Recordはこのユーザーをデータベースの中から見つけることができませんでした。代わりに、<code>find</code>メソッドは<em>例外 (exception) </em>を発生します。例外はプログラムの実行時に何か例外的なイベントが発生したことを示すために使われます。この場合、存在しないActive Recordのidによって、<code>find</code>で<code>ActiveRecord::RecordNotFound</code>例外<sup class="footnote" id="fnref-6_8"><a href="/chapters/modeling-users.html#fn-6_8">8</a></sup>が発生しました。</p>

<p>一般的な<code>find</code>メソッド以外に、Active Recordには特定の属性でユーザーを検索する方法もあります。</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="no">User</span><span class="o">.</span><span class="n">find_by_email</span><span class="p">(</span><span class="s2">&quot;mhartl@example.com&quot;</span><span class="p">)</span>
<span class="go">=&gt; #&lt;User id: 1, name: &quot;Michael Hartl&quot;, email: &quot;mhartl@example.com&quot;,</span>
<span class="go">created_at: &quot;2011-12-05 00:57:46&quot;, updated_at: &quot;2011-12-05 00:57:46&quot;&gt;</span>
</pre></div>
</div>


<p><code>find_by_email</code>は、<code>users</code>テーブルの<code>email</code>属性に基づいてActive Recordが自動的に生成するメソッドです (ご想像どおり、Active Recordは<code>find_by_name</code>というメソッドも自動的に生成します)。 これまでメールアドレスをユーザー名として使用してきたので、このような<code>find</code>は、ユーザーをサイトにログインさせる方法を学ぶときに役に立ちます (<a class="ref" href="/chapters/sign-up.html#top">第7章</a>)。ユーザー数が膨大になると<code>find_by_email</code>では検索効率が低下するのではないかと心配する方もいるかもしれませんが、焦る必要はありません。この問題およびデータベースのインデックスを使った解決策については<a class="ref" href="/chapters/modeling-users.html#sec-uniqueness_validation">6.2.5</a>で扱います。</p>

<p>ユーザーを検索する一般的な方法をあと少しだけご紹介して、この節を終わりにすることにしましょう。まず初めに<code>first</code>メソッドです。</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="no">User</span><span class="o">.</span><span class="n">first</span>
<span class="go">=&gt; #&lt;User id: 1, name: &quot;Michael Hartl&quot;, email: &quot;mhartl@example.com&quot;,</span>
<span class="go">created_at: &quot;2011-12-05 00:57:46&quot;, updated_at: &quot;2011-12-05 00:57:46&quot;&gt;</span>
</pre></div>
</div>


<p>読んで字のごとく、<code>first</code>は単にデータベースの最初のユーザーを返します。次は<code>all</code>メソッドです。</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="no">User</span><span class="o">.</span><span class="n">all</span>
<span class="go">=&gt; [#&lt;User id: 1, name: &quot;Michael Hartl&quot;, email: &quot;mhartl@example.com&quot;,</span>
<span class="go">created_at: &quot;2011-12-05 00:57:46&quot;, updated_at: &quot;2011-12-05 00:57:46&quot;&gt;,</span>
<span class="go">#&lt;User id: 2, name: &quot;A Nother&quot;, email: &quot;another@example.org&quot;, created_at:</span>
<span class="go">&quot;2011-12-05 01:05:24&quot;, updated_at: &quot;2011-12-05 01:05:24&quot;&gt;]</span>
</pre></div>
</div>


<p>ご想像のとおり、<code>all</code>はデータベースのすべてのユーザーの配列 (<a class="ref" href="/chapters/rails-flavored-ruby.html#sec-arrays_and_ranges">4.3.1</a>) を返します。</p>

<div class="label" id="sec-updating_user_objects"></div>


<h3><a id="sec-6_1_5" href="/chapters/modeling-users.html#sec-updating_user_objects" class="heading"><span class="number">6.1.5</span>ユーザーオブジェクトを更新する</a></h3>


<p>いったんオブジェクトを作成すれば、今度は何度でも更新したくなるものです。基本的な更新の方法は2つです。ひとつは、<a class="ref" href="/chapters/rails-flavored-ruby.html#sec-a_user_class">4.4.5</a>でやったように属性を個別に代入する方法です。</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="n">user</span>           <span class="c1"># Just a reminder about our user&#39;s attributes</span>
<span class="go">=&gt; #&lt;User id: 1, name: &quot;Michael Hartl&quot;, email: &quot;mhartl@example.com&quot;,</span>
<span class="go">created_at: &quot;2011-12-05 00:57:46&quot;, updated_at: &quot;2011-12-05 00:57:46&quot;&gt;</span>
<span class="gp">&gt;&gt; </span><span class="n">user</span><span class="o">.</span><span class="n">email</span> <span class="o">=</span> <span class="s2">&quot;mhartl@example.net&quot;</span>
<span class="go">=&gt; &quot;mhartl@example.net&quot;</span>
<span class="gp">&gt;&gt; </span><span class="n">user</span><span class="o">.</span><span class="n">save</span>
<span class="go">=&gt; true</span>
</pre></div>
</div>


<p>変更をデータベースに保存するために最後にsaveを実行する必要があることを忘れないでください。保存を行わずに<code>reload</code>を実行すると、データベースの情報を元にオブジェクトを再読み込みするので、以下のように変更が取り消されます。</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="n">user</span><span class="o">.</span><span class="n">email</span>
<span class="go">=&gt; &quot;mhartl@example.net&quot;</span>
<span class="gp">&gt;&gt; </span><span class="n">user</span><span class="o">.</span><span class="n">email</span> <span class="o">=</span> <span class="s2">&quot;foo@bar.com&quot;</span>
<span class="go">=&gt; &quot;foo@bar.com&quot;</span>
<span class="gp">&gt;&gt; </span><span class="n">user</span><span class="o">.</span><span class="n">reload</span><span class="o">.</span><span class="n">email</span>
<span class="go">=&gt; &quot;mhartl@example.net&quot;</span>
</pre></div>
</div>


<p>今ユーザーを更新しました。<a class="ref" href="/chapters/modeling-users.html#sec-creating_user_objects">6.1.3</a>で約束したように、マジックカラムの更新日時が更新されました。</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="n">user</span><span class="o">.</span><span class="n">created_at</span>
<span class="go">=&gt; &quot;2011-12-05 00:57:46&quot;</span>
<span class="gp">&gt;&gt; </span><span class="n">user</span><span class="o">.</span><span class="n">updated_at</span>
<span class="go">=&gt; &quot;2011-12-05 01:37:32&quot;</span>
</pre></div>
</div>


<p>属性を更新するもうひとつの方法は、<code>update_attributes</code>を使うものです。</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="n">user</span><span class="o">.</span><span class="n">update_attributes</span><span class="p">(</span><span class="nb">name</span><span class="p">:</span> <span class="s2">&quot;The Dude&quot;</span><span class="p">,</span> <span class="ss">email:</span> <span class="s2">&quot;dude@abides.org&quot;</span><span class="p">)</span>
<span class="go">=&gt; true</span>
<span class="gp">&gt;&gt; </span><span class="n">user</span><span class="o">.</span><span class="n">name</span>
<span class="go">=&gt; &quot;The Dude&quot;</span>
<span class="gp">&gt;&gt; </span><span class="n">user</span><span class="o">.</span><span class="n">email</span>
<span class="go">=&gt; &quot;dude@abides.org&quot;</span>
</pre></div>
</div>


<p><code>update_attributes</code>メソッドは属性のハッシュを受け取り、成功時には更新と保存を続けて同時に行います (保存に成功した場合は<code>true</code>を返します)。ただし、<code>attr_accessible</code> (<a class="ref" href="/chapters/modeling-users.html#sec-accessible_attributes">6.1.2.2</a>) を使って一部の属性のみをアクセス可能にしている場合、このメソッドは期待どおりに動作しません。<code>update_attributes</code>を使うと、アクセス可能な属性<em>しか</em>更新されなくなるためです。このメソッドを使用していて、モデルの特定のカラムがなぜか更新できなくなったら、それらのカラムが<code>attr_accessible</code>で指定されているかどうかを確認してください。</p>

<div class="label" id="sec-user_validations"></div>


<h2><a id="sec-6_2" href="/chapters/modeling-users.html#sec-user_validations" class="heading"><span class="number">6.2</span>ユーザーを検証する</a></h2>


<p>ついに、<a class="ref" href="/chapters/modeling-users.html#sec-user_model">6.1</a>で作成したUserモデルに、アクセス可能な<code>name</code>と<code>email</code>属性が与えられました。しかし、これらの属性はどんな値でも取ることができてしまいます。現在は (空文字を含む) あらゆる文字列が有効です。名前とメールアドレスには、もう少し何らかの制限があってよいはずです。たとえば、<code>name</code>は空であってはならず、<code>email</code>はメールアドレスのフォーマットに従う必要があります。さらに、メールアドレスをユーザーがログインするときの一意のユーザー名として使おうとしているので、メールアドレスがデータベース内で重複することのないようにする必要もあります。</p>

<p>要するに、<code>name</code>と<code>email</code>にあらゆる文字列を許すのは避けるべきです。これらの属性値には、何らかの制約を与える必要があります。Active Recordでは<em>検証 (バリデーション: validation) </em>機能を使用してそのような制約を与えることができます。ここでは、よく使われるケースのうちのいくつかについて説明します。それらは<em>存在性 (presence)</em>の検証、<em>長さ (length)</em>の検証、<em>フォーマット (format)</em>の検証、<em>一意性 (uniqueness)</em>の検証です。<a class="ref" href="/chapters/modeling-users.html#sec-has_secure_password">6.3.4</a>では、よく使われる最終検証として<em>確認 (confirmation)</em>を追加します。<a class="ref" href="/chapters/sign-up.html#sec-signup_failure">7.3</a>では、ユーザーが制約に違反したときに、検証機能によって自動的に表示される有用なエラーメッセージをお見せします。</p>

<div class="label" id="sec-initial_user_tests"></div>


<h3><a id="sec-6_2_1" href="/chapters/modeling-users.html#sec-initial_user_tests" class="heading"><span class="number">6.2.1</span>最初のユーザーテスト</a></h3>


<p>サンプルアプリケーションの他の機能と同様、Userモデルへの検証の追加もテスト駆動開発 (TDD) で行います。その理由は、以下のフラグを</p>

<pre class="verbatim">--no-test-framework</pre>


<p>(<a class="ref" href="/chapters/filling-in-the-layout.html#code-generate_users_controller">リスト5.28</a>の例とは異なり) Userモデルを作成したときに渡さなかったからです。<a class="ref" href="/chapters/modeling-users.html#code-generate_user_model">リスト6.1</a>のコマンドは、ユーザーをテストするための初期のspecを作成します。しかし今回の場合、specは実質的には空です (<a class="ref" href="/chapters/modeling-users.html#code-default_user_spec">リスト6.7</a>)。</p>

<div class="label" id="code-default_user_spec"></div>


<div class="codelisting">
<div class="listing"><span class="header">リスト6.7</span> <span class="description">実質的に空になっているデフォルトのUser spec。</span><br /><span class="description"> <code>spec/models/user_spec.rb</code></span> </div>
<div class="code"><div class="highlight"><pre><span class="nb">require</span> <span class="s1">&#39;spec_helper&#39;</span>

<span class="n">describe</span> <span class="no">User</span> <span class="k">do</span>
  <span class="n">pending</span> <span class="s2">&quot;add some examples to (or delete) </span><span class="si">#{</span><span class="bp">__FILE__</span><span class="si">}</span><span class="s2">&quot;</span>
<span class="k">end</span>
</pre></div>
</div></div>


<p>上のコードでは<code>pending</code>メソッドだけが置かれており、何か意味のあるコードでspecを埋めるように促しています。このコードの効果は、Userモデルのspecを実行することで確認できます。</p>

<div class="code"><div class="highlight"><pre><span class="gp">$</span> bundle <span class="nb">exec </span>rspec spec/models/user_spec.rb 
<span class="go">*</span>


<span class="go">Finished in 0.01999 seconds</span>
<span class="go">1 example, 0 failures, 1 pending</span>

<span class="go">Pending:</span>
<span class="go">  User add some examples to (or delete)</span>
<span class="go">  /Users/mhartl/rails_projects/sample_app/spec/models/user_spec.rb</span>
<span class="go">  (Not Yet Implemented)</span>
</pre></div>
</div>


<p>多くのシステムでは、pendingのspecはコマンドライン上で黄色で表示されます。それは、成功 (緑) と失敗 (赤) の間であることを意味します。</p>

<p>デフォルトのspecのアドバイスに従い、<a class="ref" href="/chapters/modeling-users.html#code-user_spec">リスト6.8</a>に示したいくつかのRSpecの例に置き換えてみましょう。</p>

<div class="label" id="code-user_spec"></div>


<div class="codelisting">
<div class="listing"><span class="header">リスト6.8</span> <span class="description"><code>:name</code>と<code>:email</code>属性のテスト。</span><br /><span class="description"> <code>spec/models/user_spec.rb</code></span> </div>
<div class="code"><div class="highlight"><pre><span class="nb">require</span> <span class="s1">&#39;spec_helper&#39;</span>

<span class="n">describe</span> <span class="no">User</span> <span class="k">do</span>

  <span class="n">before</span> <span class="p">{</span> <span class="vi">@user</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="nb">name</span><span class="p">:</span> <span class="s2">&quot;Example User&quot;</span><span class="p">,</span> <span class="ss">email:</span> <span class="s2">&quot;user@example.com&quot;</span><span class="p">)</span> <span class="p">}</span>

  <span class="n">subject</span> <span class="p">{</span> <span class="vi">@user</span> <span class="p">}</span>

  <span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">respond_to</span><span class="p">(</span><span class="ss">:name</span><span class="p">)</span> <span class="p">}</span>
  <span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">respond_to</span><span class="p">(</span><span class="ss">:email</span><span class="p">)</span> <span class="p">}</span>
<span class="k">end</span>
</pre></div>
</div></div>


<p><a class="ref" href="/chapters/filling-in-the-layout.html#code-pretty_page_tests">リスト5.27</a>で見た<code>before</code>ブロックは前処理用で、各サンプルが実行される前にそのブロックの中のコードを実行します。この場合、<code>User.new</code>と初期化用の有効なハッシュを使って、新しい<code>@user</code>インスタンス変数を作成します。そして以下のコードは、</p>

<div class="code"><div class="highlight"><pre><span class="n">subject</span> <span class="p">{</span> <span class="vi">@user</span> <span class="p">}</span>
</pre></div>
</div>


<p><a class="ref" href="/chapters/filling-in-the-layout.html#sec-pretty_rspec">5.3.4</a>で<code>page</code>変数を扱ったときと同じように、<code>@user</code>をテストサンプルのデフォルトのsubjectとして設定します。</p>

<p><a class="ref" href="/chapters/modeling-users.html#code-user_spec">リスト6.8</a>の2つのサンプルは、<code>name</code>属性と<code>email</code>属性の存在をテストします。</p>

<div class="code"><div class="highlight"><pre><span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">respond_to</span><span class="p">(</span><span class="ss">:name</span><span class="p">)</span> <span class="p">}</span>
<span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">respond_to</span><span class="p">(</span><span class="ss">:email</span><span class="p">)</span> <span class="p">}</span>
</pre></div>
</div>


<p>これらのサンプルではRubyの<code>respond_to?</code>メソッドを暗黙的に使っています。このメソッドはシンボルを1つ引数として受け取り、引数として与えられたそのシンボルが表すメソッドまたは属性にオブジェクトが応答する場合は<code>true</code>を返し、応答しない場合は<code>false</code>を返します。</p>

<div class="code"><div class="highlight"><pre><span class="go">$ rails console --sandbox</span>
<span class="gp">&gt;&gt; </span><span class="n">user</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">new</span>
<span class="gp">&gt;&gt; </span><span class="n">user</span><span class="o">.</span><span class="n">respond_to?</span><span class="p">(</span><span class="ss">:name</span><span class="p">)</span>
<span class="go">=&gt; true</span>
<span class="gp">&gt;&gt; </span><span class="n">user</span><span class="o">.</span><span class="n">respond_to?</span><span class="p">(</span><span class="ss">:foobar</span><span class="p">)</span>
<span class="go">=&gt; false</span>
</pre></div>
</div>


<p>(<a class="ref" href="/chapters/rails-flavored-ruby.html#sec-objects_and_message_passing">4.2.3</a>でも説明したとおり、Rubyではtrue/falseの真偽値を返すメソッド名の末尾に?記号を置く慣習があることを思い出してください)。これらのテストは、RSpecで使われる<em>論理値の慣習</em>に依存しています。以下のコードは、</p>

<div class="code"><div class="highlight"><pre><span class="vi">@user</span><span class="o">.</span><span class="n">respond_to?</span><span class="p">(</span><span class="ss">:name</span><span class="p">)</span>
</pre></div>
</div>


<p>以下のRSpecのコードでテストされます。</p>

<div class="code"><div class="highlight"><pre><span class="vi">@user</span><span class="o">.</span><span class="n">should</span> <span class="n">respond_to</span><span class="p">(</span><span class="ss">:name</span><span class="p">)</span>
</pre></div>
</div>


<p>しかし、<code>subject { @user }</code>があるので、テストの中で<code>@user</code>を使わずに以下のように書くことができます。</p>

<div class="code"><div class="highlight"><pre><span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">respond_to</span><span class="p">(</span><span class="ss">:name</span><span class="p">)</span> <span class="p">}</span>
</pre></div>
</div>


<p>このようなテストのおかげで、テスト駆動開発をベースに新しい属性やメソッドをUserモデルに追加することができます。さらに、すべての<code>User</code>オブジェクトがこれらのメソッドに応答する必要があるという仕様もここで明らかになりました。</p>

<p>この時点ではテストが失敗することを検証しておく必要があります。</p>

<div class="code"><div class="highlight"><pre><span class="gp">$</span> bundle <span class="nb">exec </span>rspec spec/
</pre></div>
</div>


<p><a class="ref" href="/chapters/modeling-users.html#sec-database_migrations">6.1.1</a>で、<code>rake db:migrate</code>を使って開発データベースを作成しましたが、上のテストは失敗します。それというのも、<em>テストデータベース</em>はまだデータモデルの存在を知らないからです (実際、テストデータベースはまだ存在しません)。<code>db:test:prepare</code>というRakeタスクを使用して、正しい構造のテスト用データベースを作ることができます。これでテストにパスするようになります。</p>

<div class="code"><div class="highlight"><pre><span class="gp">$</span> bundle <span class="nb">exec </span>rake db:test:prepare
</pre></div>
</div>


<p>上のコマンドは、単に開発データベースのデータモデル<code>db/development.sqlite3</code>がテストデータベース<code>db/test.sqlite3</code>に反映されるようにするものです。よくある失敗のひとつに、マイグレーションの後でこのRakeタスクが実行できなくなるというのがあります。さらに、テストデータベースはときどき壊れることがあるので、その場合はリセットが必要です。もしテストスイートが理由もなく壊れるようなことがあれば、<code>rake db:test:prepare</code>を実行して、この問題が解決するか確認してみてください。</p>

<div class="label" id="sec-presence_validation"></div>


<h3><a id="sec-6_2_2" href="/chapters/modeling-users.html#sec-presence_validation" class="heading"><span class="number">6.2.2</span>プレゼンスを検証する</a></h3>


<p>おそらく最も基本的な検証 (validation) は<em>プレゼンス (存在性) </em>です。これは単に、与えられた属性が存在することを検証します。たとえばこの節では、ユーザーがデータベースに保存される前にnameとemailフィールドの両方が存在することを保証します。<a class="ref" href="/chapters/sign-up.html#sec-signup_error_messages">7.3.2</a>では、この要求を新しいユーザーを作るためのユーザー登録フォームにまで徹底させる方法を確認します。</p>

<p>最初に<code>name</code>属性の存在を確認するテストを行いましょう。テスト駆動開発の最初のステップは<em>失敗する</em>テスト (<a class="ref" href="/chapters/static-pages.html#sec-TDD">3.2.1</a>) を書くことですが、今回は適切なテストを書くための検証機能についてまだ十分に理解していないので、まず最初に検証を書きます。検証についてはコンソールを使って理解することにします。次に、検証部分をコメントアウトし、失敗するテストを書いて、最後にコメントアウトを解除した検証でテストがパスするかどうかを確認します。この手続きは、このような単純なテストでは大げさで気取ったものに感じられるかもしれませんが、著者はこれまでにテストそのものが間違っている “単純な” テストを山ほど見てきました。テスト駆動開発を慎重に進めることは、テストが正しく進められているという自信を得る<em>唯一の</em>方法です (上で紹介したコメントアウトのテクニックは、コードはあってもテストがどこにもないような<a href="http://en.wiktionary.org/wiki/quelle_horreur"><em>ひどい</em></a>アプリケーションを急いで救出するときにも役に立ちます)。</p>

<p>name属性の存在を検査する方法は、<a class="ref" href="/chapters/modeling-users.html#code-validates_presence_of_name">リスト6.9</a>に示したとおり、<code>validates</code>メソッドに<code>presence: true</code>という引数を与えて使うことです。<code>presence: true</code>という引数は、要素がひとつの<em>オプションハッシュ</em>です。<a class="ref" href="/chapters/rails-flavored-ruby.html#sec-css_revisited">4.3.4</a>のようにメソッドの最後の引数としてハッシュを渡す場合、波かっこを付けなくても問題ありません (<a class="ref" href="/chapters/filling-in-the-layout.html#sec-adding_to_the_layout">5.1.1</a>でも説明したように、Railsのオプションハッシュは繰り返し登場するテーマです)。</p>

<div class="label" id="code-validates_presence_of_name"></div>


<div class="codelisting">
<div class="listing"><span class="header">リスト6.9</span> <span class="description"><code>name</code>属性の存在を検証する。</span><br /><span class="description"> <code>app/models/user.rb</code></span> </div>
<div class="code"><div class="highlight"><pre><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="ss">ActiveRecord::Base</span> 
  <span class="n">attr_accessible</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">:email</span>

  <span class="n">validates</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">presence:</span> <span class="kp">true</span>
<span class="k">end</span>
</pre></div>
</div></div>


<p><a class="ref" href="/chapters/modeling-users.html#code-validates_presence_of_name">リスト6.9</a>は一見魔法のように見えるかもしれません。しかし<code>attr_accessible</code>同様、<code>validates</code>もただのメソッドに過ぎません。かっこを使用して<a class="ref" href="/chapters/modeling-users.html#code-validates_presence_of_name">リスト6.9</a>を同等のコードに書き換えたものを以下に示します。</p>

<div class="code"><div class="highlight"><pre><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="ss">ActiveRecord::Base</span> 
  <span class="n">attr_accessible</span><span class="p">(</span><span class="ss">:name</span><span class="p">,</span> <span class="ss">:email</span><span class="p">)</span>

  <span class="n">validates</span><span class="p">(</span><span class="ss">:name</span><span class="p">,</span> <span class="ss">presence:</span> <span class="kp">true</span><span class="p">)</span>
<span class="k">end</span>
</pre></div>
</div>


<p>コンソールを起動して、Userモデルに検証を追加した効果を見てみましょう<sup class="footnote" id="fnref-6_9"><a href="/chapters/modeling-users.html#fn-6_9">9</a></sup>。</p>

<div class="code"><div class="highlight"><pre><span class="go">$ rails console --sandbox</span>
<span class="gp">&gt;&gt; </span><span class="n">user</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="nb">name</span><span class="p">:</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="ss">email:</span> <span class="s2">&quot;mhartl@example.com&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt; </span><span class="n">user</span><span class="o">.</span><span class="n">save</span>
<span class="go">=&gt; false</span>
<span class="gp">&gt;&gt; </span><span class="n">user</span><span class="o">.</span><span class="n">valid?</span>
<span class="go">=&gt; false</span>
</pre></div>
</div>


<p><code>user.save</code>は<code>false</code>を返しました。これは保存に失敗したことを意味します。最後のコマンドは、<code>valid?</code>メソッドで、オブジェクトがひとつ以上の検証に失敗したときに<code>false</code>を返します。 すべての検証がパスした場合は<code>true</code>を返します。今回の場合、検証がひとつしかないので、どの検証が失敗したかわかります。しかし、失敗したときに作られる<code>errors</code>オブジェクトを使って確認すれば、さらに便利です。</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="n">user</span><span class="o">.</span><span class="n">errors</span><span class="o">.</span><span class="n">full_messages</span>
<span class="go">=&gt; [&quot;Name can&#39;t be blank&quot;]</span>
</pre></div>
</div>


<p>(このエラーメッセージから、Railsが属性の存在性を検査するときに<code>blank?</code>メソッド (<a class="ref" href="/chapters/rails-flavored-ruby.html#sec-modifying_built_in_classes">4.4.3</a>の終わりに登場) を使用していることが伺えます。)</p>

<p>次は失敗するテストです。最初に、テストが失敗することを確認するために、この時点 (<a class="ref" href="/chapters/modeling-users.html#code-commented_out_validation">リスト6.10</a>) で検証をコメントアウトしてみましょう。</p>

<div class="label" id="code-commented_out_validation"></div>


<div class="codelisting">
<div class="listing"><span class="header">リスト6.10</span> <span class="description">失敗するテストを確認するために検証をコメントアウトする。</span><br /><span class="description"> <code>app/models/user.rb</code></span> </div>
<div class="code"><div class="highlight"><pre><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="ss">ActiveRecord::Base</span> 
  <span class="n">attr_accessible</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">:email</span>

  <span class="c1"># validates :name, presence: true</span>
<span class="k">end</span>
</pre></div>
</div></div>


<p>最初の段階の検証テストを<a class="ref" href="/chapters/modeling-users.html#code-failing_validates_name_spec">リスト6.11</a>に示します。</p>

<div class="label" id="code-failing_validates_name_spec"></div>


<div class="codelisting">
<div class="listing"><span class="header">リスト6.11</span> <span class="description"><code>name</code>属性の検証に対する、失敗するテスト。</span><br /><span class="description"> <code>spec/models/user_spec.rb</code></span> </div>
<div class="code"><div class="highlight"><pre><span class="nb">require</span> <span class="s1">&#39;spec_helper&#39;</span>

<span class="n">describe</span> <span class="no">User</span> <span class="k">do</span>

  <span class="n">before</span> <span class="k">do</span>
    <span class="vi">@user</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="nb">name</span><span class="p">:</span> <span class="s2">&quot;Example User&quot;</span><span class="p">,</span> <span class="ss">email:</span> <span class="s2">&quot;user@example.com&quot;</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="n">subject</span> <span class="p">{</span> <span class="vi">@user</span> <span class="p">}</span>

  <span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">respond_to</span><span class="p">(</span><span class="ss">:name</span><span class="p">)</span> <span class="p">}</span>
  <span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">respond_to</span><span class="p">(</span><span class="ss">:email</span><span class="p">)</span> <span class="p">}</span>

  <span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">be_valid</span> <span class="p">}</span>

  <span class="n">describe</span> <span class="s2">&quot;when name is not present&quot;</span> <span class="k">do</span>
    <span class="n">before</span> <span class="p">{</span> <span class="vi">@user</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span> <span class="p">}</span>
    <span class="n">it</span> <span class="p">{</span> <span class="n">should_not</span> <span class="n">be_valid</span> <span class="p">}</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div></div>


<p>最初の新しいサンプルは、基本となるただのテストです。これを使用して、まず<code>@user</code>オブジェクトが有効かどうかを確認します。</p>

<div class="code"><div class="highlight"><pre><span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">be_valid</span> <span class="p">}</span>
</pre></div>
</div>


<p>上のコードは<a class="ref" href="/chapters/modeling-users.html#sec-initial_user_tests">6.2.1</a>で見た別のRSpecの真偽値の慣習を示すサンプルです。あるオブジェクトが、真偽値を返す<code>foo?</code>というメソッドに応答するのであれば、それに対応する<code>be_foo</code>というテストメソッドが (自動的に) 存在します。この場合、以下のメソッド呼び出しの結果をテストすることができます。</p>

<div class="code"><div class="highlight"><pre><span class="vi">@user</span><span class="o">.</span><span class="n">valid?</span>
</pre></div>
</div>


<p>上のコードの場合、対応するテストコードは以下のようになります。</p>

<div class="code"><div class="highlight"><pre><span class="vi">@user</span><span class="o">.</span><span class="n">should</span> <span class="n">be_valid</span>
</pre></div>
</div>


<p>以前と同じように、<code>subject { @user }</code>があるので<code>@user</code>を使わずに書くことができます。</p>

<div class="code"><div class="highlight"><pre><span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">be_valid</span> <span class="p">}</span>
</pre></div>
</div>


<p>2つ目のテストは、まずユーザーのnameに無効な値 (blank) を設定し、<code>@user</code>オブジェクトの結果も無効になることをテストして確認します。</p>

<div class="code"><div class="highlight"><pre><span class="n">describe</span> <span class="s2">&quot;when name is not present&quot;</span> <span class="k">do</span>
  <span class="n">before</span> <span class="p">{</span> <span class="vi">@user</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span> <span class="p">}</span>
  <span class="n">it</span> <span class="p">{</span> <span class="n">should_not</span> <span class="n">be_valid</span> <span class="p">}</span>
<span class="k">end</span>
</pre></div>
</div>


<p>ユーザーのnameに無効な値 (blank) を設定するには<code>before</code>ブロックを使います。次にユーザーオブジェクトの結果が無効であることを確認します。</p>

<p>この時点でテストが失敗することを確認してください。</p>

<div class="code"><div class="highlight"><pre><span class="gp">$</span> bundle <span class="nb">exec </span>rspec spec/models/user_spec.rb
<span class="go">...</span><span class="go">F</span>
<span class="go">4 examples, 1 failure</span>
</pre></div>
</div>


<p>それではここで、テストにパスするために検証部分のコメントアウトを解除しましょう (つまり、<a class="ref" href="/chapters/modeling-users.html#code-commented_out_validation">リスト6.10</a>を<a class="ref" href="/chapters/modeling-users.html#code-validates_presence_of_name">リスト6.9</a>に戻します)。</p>

<div class="code"><div class="highlight"><pre><span class="gp">$</span> bundle <span class="nb">exec </span>rspec spec/models/user_spec.rb
<span class="go">....</span>
<span class="go">4 examples, 0 failures</span>
</pre></div>
</div>


<p>もちろん、今度はメールアドレスの存在性も検証しましょう。このテスト (<a class="ref" href="/chapters/modeling-users.html#code-validates_email_spec">リスト6.12</a>) は、<code>name</code>属性のテストと似ています。</p>

<div class="label" id="code-validates_email_spec"></div>


<div class="codelisting">
<div class="listing"><span class="header">リスト6.12</span> <span class="description"><code>email</code>属性の存在性のテスト。</span><br /><span class="description"> <code>spec/models/user_spec.rb</code></span> </div>
<div class="code"><div class="highlight"><pre><span class="nb">require</span> <span class="s1">&#39;spec_helper&#39;</span>

<span class="n">describe</span> <span class="no">User</span> <span class="k">do</span>

  <span class="n">before</span> <span class="k">do</span>
    <span class="vi">@user</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="nb">name</span><span class="p">:</span> <span class="s2">&quot;Example User&quot;</span><span class="p">,</span> <span class="ss">email:</span> <span class="s2">&quot;user@example.com&quot;</span><span class="p">)</span>
  <span class="k">end</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="n">describe</span> <span class="s2">&quot;when email is not present&quot;</span> <span class="k">do</span>
    <span class="n">before</span> <span class="p">{</span> <span class="vi">@user</span><span class="o">.</span><span class="n">email</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span> <span class="p">}</span>
    <span class="n">it</span> <span class="p">{</span> <span class="n">should_not</span> <span class="n">be_valid</span> <span class="p">}</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div></div>


<p>以下の<a class="ref" href="/chapters/modeling-users.html#code-validates_presence_of_email">リスト6.13</a>に示すように、メールアドレス検証の実装も名前の検証と実質的に同じです。</p>

<div class="label" id="code-validates_presence_of_email"></div>


<div class="codelisting">
<div class="listing"><span class="header">リスト6.13</span> <span class="description"><code>name</code>属性と<code>email</code>属性の存在性を検証する。</span><br /><span class="description"> <code>app/models/user.rb</code></span> </div>
<div class="code"><div class="highlight"><pre><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="ss">ActiveRecord::Base</span> 
  <span class="n">attr_accessible</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">:email</span>

  <span class="n">validates</span> <span class="ss">:name</span><span class="p">,</span>  <span class="ss">presence:</span> <span class="kp">true</span>
  <span class="n">validates</span> <span class="ss">:email</span><span class="p">,</span> <span class="ss">presence:</span> <span class="kp">true</span>
<span class="k">end</span>
</pre></div>
</div></div>


<p>これですべてのテストにパスするはずです。これで、存在性の検証は完成しました。</p>

<div class="label" id="sec-length_validation"></div>


<h3><a id="sec-6_2_3" href="/chapters/modeling-users.html#sec-length_validation" class="heading"><span class="number">6.2.3</span>長さを検証する</a></h3>


<p>各ユーザーは、Userモデル上に名前を持つよう強制されます。しかし、これだけでは十分ではありません。ユーザーの名前はサンプルWebサイトに表示されるものなので、名前の長さにも制限を与える必要があります。<a class="ref" href="/chapters/modeling-users.html#sec-presence_validation">6.2.2</a>で既に同じような作業を行ったので、この実装は簡単です。</p>

<p>まずはテストを作成します。最長のユーザー名の長さに科学的な根拠はありませんので、単に<code>50</code>という上限として手頃な値を使うことにします。つまりここでは、<code>51</code>文字の名前は長すぎることを検証します (<a class="ref" href="/chapters/modeling-users.html#code-length_validation_test">リスト6.14</a>)。</p>

<div class="label" id="code-length_validation_test"></div>


<div class="codelisting">
<div class="listing"><span class="header">リスト6.14</span> <span class="description"><code>name</code>の長さ検証のテスト。</span><br /><span class="description"> <code>spec/models/user_spec.rb</code></span> </div>
<div class="code"><div class="highlight"><pre><span class="nb">require</span> <span class="s1">&#39;spec_helper&#39;</span>

<span class="n">describe</span> <span class="no">User</span> <span class="k">do</span>

  <span class="n">before</span> <span class="k">do</span>
    <span class="vi">@user</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="nb">name</span><span class="p">:</span> <span class="s2">&quot;Example User&quot;</span><span class="p">,</span> <span class="ss">email:</span> <span class="s2">&quot;user@example.com&quot;</span><span class="p">)</span>
  <span class="k">end</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="n">describe</span> <span class="s2">&quot;when name is too long&quot;</span> <span class="k">do</span>
    <span class="n">before</span> <span class="p">{</span> <span class="vi">@user</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;a&quot;</span> <span class="o">*</span> <span class="mi">51</span> <span class="p">}</span>
    <span class="n">it</span> <span class="p">{</span> <span class="n">should_not</span> <span class="n">be_valid</span> <span class="p">}</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div></div>


<p><a class="ref" href="/chapters/modeling-users.html#code-length_validation_test">リスト6.14</a>では、51文字の文字列を簡単に作るために “文字列のかけ算” を使いました。結果をコンソール上で確認できます。</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="s2">&quot;a&quot;</span> <span class="o">*</span> <span class="mi">51</span>
<span class="go">=&gt; &quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot;</span>
<span class="gp">&gt;&gt; </span><span class="p">(</span><span class="s2">&quot;a&quot;</span> <span class="o">*</span> <span class="mi">51</span><span class="p">)</span><span class="o">.</span><span class="n">length</span>
<span class="go">=&gt; 51</span>
</pre></div>
</div>


<p>今の時点では<a class="ref" href="/chapters/modeling-users.html#code-length_validation_test">リスト6.14</a>のテストは失敗するはずです。これをパスさせるためには、長さを強制するための検証の引数について知っておく必要があります。<code>:maximum</code>パラメータと共に用いられる<code>:length</code>は、長さの上限を強制します (<a class="ref" href="/chapters/modeling-users.html#code-length_validation">リスト6.15</a>)。</p>

<div class="label" id="code-length_validation"></div>


<div class="codelisting">
<div class="listing"><span class="header">リスト6.15</span> <span class="description"><code>name</code>属性の長さの検証を追加する。</span><br /><span class="description"> <code>app/models/user.rb</code></span> </div>
<div class="code"><div class="highlight"><pre><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="ss">ActiveRecord::Base</span> 
  <span class="n">attr_accessible</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">:email</span>

  <span class="n">validates</span> <span class="ss">:name</span><span class="p">,</span>  <span class="ss">presence:</span> <span class="kp">true</span><span class="p">,</span> <span class="ss">length:</span> <span class="p">{</span> <span class="ss">maximum:</span> <span class="mi">50</span> <span class="p">}</span>
  <span class="n">validates</span> <span class="ss">:email</span><span class="p">,</span> <span class="ss">presence:</span> <span class="kp">true</span>
<span class="k">end</span>
</pre></div>
</div></div>


<p>これでテストにパスするはずです。パスしたテストスイートを流用して、今度は少し難しい、メールアドレスのフォーマット検証作業に取りかかりましょう。</p>

<div class="label" id="sec-format_validation"></div>


<h3><a id="sec-6_2_4" href="/chapters/modeling-users.html#sec-format_validation" class="heading"><span class="number">6.2.4</span>フォーマットを検証する</a></h3>


<p><code>name</code>属性の検証には、空文字でない、名前が51文字未満であるという最小限の制約しか与えていませんでした。<code>email</code>属性の場合は、もっと厳重な要求を満たさなければなりません。これまでは空のメールアドレスのみを禁止してきましたが、ここではメールアドレスにおなじみのパターン<code>user@example.com</code>に合っているかどうかも確認することを要求します。</p>

<p>なお、ここで使用するテストや検証は、形式の有効なメールアドレスを受け入れ、形式の無効なものを拒否するだけであり、決して徹底的なものではないという点にご注意ください。最初に、有効なメールアドレスと無効なメールアドレスのコレクションに対するテストを行いましょう。このコレクションを作るために、以下のコンソールセッションに示したような、文字列の配列を簡単に作れる<code>%w[]</code>という便利なテクニックを知っておくと良いでしょう。</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="sx">%w[foo bar baz]</span>
<span class="go">=&gt; [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;]</span>
<span class="gp">&gt;&gt; </span><span class="n">addresses</span> <span class="o">=</span> <span class="sx">%w[user@foo.</span><span class="sx">COM THE_US-ER@foo.bar.org first.last@foo.jp]</span>
<span class="go">=&gt; [&quot;user@foo.</span><span class="go">COM&quot;, &quot;THE_US-ER@foo.bar.org&quot;, &quot;first.last@foo.jp&quot;]</span>
<span class="gp">&gt;&gt; </span><span class="n">addresses</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">address</span><span class="o">|</span>
<span class="gp">?</span><span class="gp">&gt; </span>  <span class="nb">puts</span> <span class="n">address</span>
<span class="gp">&gt;&gt; </span><span class="k">end</span>
<span class="go">user@foo.</span><span class="go">COM</span>
<span class="go">THE_US-ER@foo.bar.org</span>
<span class="go">first.last@foo.jp</span>
</pre></div>
</div>


<p><code>each</code>メソッドを使って<code>メールアドレス</code>の配列の各要素を繰り返し取り出しました (<a class="ref" href="/chapters/rails-flavored-ruby.html#sec-blocks">4.3.2</a>)。このテクニックを学んだことで、基本となるメールアドレスフォーマット検証のテストを書く準備が整いました (<a class="ref" href="/chapters/modeling-users.html#code-email_format_validation_tests">リスト6.16</a>)。</p>

<div class="label" id="code-email_format_validation_tests"></div>


<div class="codelisting">
<div class="listing"><span class="header">リスト6.16</span> <span class="description">メールアドレスフォーマットの検証テスト。</span><br /><span class="description"> <code>spec/models/user_spec.rb</code></span> </div>
<div class="code"><div class="highlight"><pre><span class="nb">require</span> <span class="s1">&#39;spec_helper&#39;</span>

<span class="n">describe</span> <span class="no">User</span> <span class="k">do</span>

  <span class="n">before</span> <span class="k">do</span>
    <span class="vi">@user</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="nb">name</span><span class="p">:</span> <span class="s2">&quot;Example User&quot;</span><span class="p">,</span> <span class="ss">email:</span> <span class="s2">&quot;user@example.com&quot;</span><span class="p">)</span>
  <span class="k">end</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="n">describe</span> <span class="s2">&quot;when email format is invalid&quot;</span> <span class="k">do</span>
    <span class="n">it</span> <span class="s2">&quot;should be invalid&quot;</span> <span class="k">do</span>
      <span class="n">addresses</span> <span class="o">=</span> <span class="sx">%w[user@foo,com user_at_foo.org example.user@foo.</span>
<span class="sx">                     foo@bar_baz.com foo@bar+baz.com]</span>
      <span class="n">addresses</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">invalid_address</span><span class="o">|</span>
        <span class="vi">@user</span><span class="o">.</span><span class="n">email</span> <span class="o">=</span> <span class="n">invalid_address</span>
        <span class="vi">@user</span><span class="o">.</span><span class="n">should_not</span> <span class="n">be_valid</span>
      <span class="k">end</span>      
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="n">describe</span> <span class="s2">&quot;when email format is valid&quot;</span> <span class="k">do</span>
    <span class="n">it</span> <span class="s2">&quot;should be valid&quot;</span> <span class="k">do</span>
      <span class="n">addresses</span> <span class="o">=</span> <span class="sx">%w[user@foo.</span><span class="sx">COM A_US-ER@f.b.org frst.lst@foo.jp a+b@baz.cn]</span>
      <span class="n">addresses</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">valid_address</span><span class="o">|</span>
        <span class="vi">@user</span><span class="o">.</span><span class="n">email</span> <span class="o">=</span> <span class="n">valid_address</span>
        <span class="vi">@user</span><span class="o">.</span><span class="n">should</span> <span class="n">be_valid</span>
      <span class="k">end</span>      
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div></div>


<p>既に述べたとおり、上のテストはすべてを盛り込んだものではありませんが、一般的に有効なメールアドレスの形式である<code>user@foo.COM</code>、<code>THE_US-ER@foo.bar.org </code> (大文字、アンダースコア、複合ドメイン) 、<code>first.last@foo.jp</code> (一般的な企業のユーザー名「<code>名.姓</code>」と、2文字のトップレベルドメイン「<code>jp</code>」) を、いくつかの無効な形式と共に確認します。</p>

<p>メールアドレスのフォーマット検証を行うアプリケーションコードでは、<code>validates</code>メソッドの<code>:format</code>引数に、フォーマットを定義するための<em>正規表現 (regular expression)</em> (または<em>regex</em>) を与えます (<a class="ref" href="/chapters/modeling-users.html#code-validates_format_of_email">リスト6.17</a>)。</p>

<div class="label" id="code-validates_format_of_email"></div>


<div class="codelisting">
<div class="listing"><span class="header">リスト6.17</span> <span class="description">正規表現を使ったメールアドレスフォーマットの検証。</span><br /><span class="description"> <code>app/models/user.rb</code></span> </div>
<div class="code"><div class="highlight"><pre><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="ss">ActiveRecord::Base</span>
  <span class="n">attr_accessible</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">:email</span>

  <span class="n">validates</span> <span class="ss">:name</span><span class="p">,</span>  <span class="ss">presence:</span> <span class="kp">true</span><span class="p">,</span> <span class="ss">length:</span> <span class="p">{</span> <span class="ss">maximum:</span> <span class="mi">50</span> <span class="p">}</span>
  <span class="no">VALID_EMAIL_REGEX</span> <span class="o">=</span> <span class="sr">/\A[\w+\-.]+@[a-z\d\-.]</span><span class="sr">+\.[a-z]+\z/i</span>
  <span class="n">validates</span> <span class="ss">:email</span><span class="p">,</span> <span class="ss">presence:</span> <span class="kp">true</span><span class="p">,</span> <span class="nb">format</span><span class="p">:</span> <span class="p">{</span> <span class="ss">with:</span> <span class="no">VALID_EMAIL_REGEX</span> <span class="p">}</span>
<span class="k">end</span>
</pre></div>
</div></div>


<p>正規表現<code>VALID_EMAIL_REGEX</code>は<em>定数</em>です。大文字で始まる名前はRubyでは定数を意味します。以下のコードは、</p>

<div class="code"><div class="highlight"><pre>  <span class="no">VALID_EMAIL_REGEX</span> <span class="o">=</span> <span class="sr">/\A[\w+\-.]+@[a-z\d\-.]</span><span class="sr">+\.[a-z]+\z/i</span>
  <span class="n">validates</span> <span class="ss">:email</span><span class="p">,</span> <span class="ss">presence:</span> <span class="kp">true</span><span class="p">,</span> <span class="nb">format</span><span class="p">:</span> <span class="p">{</span> <span class="ss">with:</span> <span class="no">VALID_EMAIL_REGEX</span> <span class="p">}</span>
</pre></div>
</div>


<p>このパターンに一致するメールアドレスだけが有効であることをチェックします (<code>VALID_EMAIL_REGEX</code>は大文字で始まるので、Rubyの<em>定数</em>として扱われ、値は変更できません)。</p>

<p>ところで、この正規表現パターンはどうやって作ればよいのでしょうか。正規表現は簡潔な (<a href="http://catb.org/jargon/html/L/line-noise.html">読めない</a>という人もいるにはいますが) テキストパターンマッチング言語から成ります。正規表現を組み立てることを学ぶのはそれだけでひとつの技術分野であり、手短に説明するのは簡単ではありませんが、ともあれ最初の説明のために<code>VALID_EMAIL_REGEX</code>をビットサイズの破片に分解しました (<a class="ref" href="/chapters/modeling-users.html#table-valid_email_regex">表6.1</a>)<sup class="footnote" id="fnref-6_10"><a href="/chapters/modeling-users.html#fn-6_10">10</a></sup>。限られた紙面で正規表現を本格的に学ぶには、素晴らしい正規表現エディタである<a href="http://www.rubular.com/">Rubular</a> (<a class="ref" href="/chapters/modeling-users.html#fig-rubular">図6.4</a>) が必要不可欠です<sup class="footnote" id="fnref-6_11"><a href="/chapters/modeling-users.html#fn-6_11">11</a></sup>。RubularのWebサイトは、正規表現を作るための美しく対話的なインターフェイスを持っています。また、手軽な正規表現のクイックリファレンスにもなります。Rubularのサイトをブラウザで開き、<a class="ref" href="/chapters/modeling-users.html#table-valid_email_regex">表6.1</a>の表現をひとつずつ入力して結果を確かめながら正規表現を学ぶことをぜひともお勧めします。正規表現について学んだことがなくても、Rubularを使えば数時間で慣れることができます (注: <a class="ref" href="/chapters/modeling-users.html#code-validates_format_of_email">リスト6.17</a>の正規表現をRubularで使う場合、冒頭の<tt class="verb">\A</tt>と末尾の<tt class="verb">\z</tt>の文字は含めないでください)。</p>

<div class="label" id="table-valid_email_regex"></div>


<div class="table"><div class="center">
<table class="tabular"><tr><th class="align_left"><strong>表現</strong></th><th class="align_left"><strong>意味</strong></th></tr><tr class="top_bar"><td class="align_left"><tt class="verb">/\A[\w+\-.]+@[a-z\d\-.]</tt><tt class="verb">+\.[a-z]+\z/i</tt></td><td class="align_left">(完全な正規表現)</td></tr><tr><td class="align_left"><tt class="verb">/</tt></td><td class="align_left">正規表現の開始を示す</td></tr><tr><td class="align_left"><tt class="verb">\A</tt></td><td class="align_left">文字列の先頭</td></tr><tr><td class="align_left"><tt class="verb">[\w+\-.]</tt><tt class="verb">+</tt></td><td class="align_left">英文字、数字、プラス記号、ハイフン、ドットのいずれかを少なくとも1文字以上繰り返す</td></tr><tr><td class="align_left"><tt class="verb">@</tt></td><td class="align_left">アットマーク</td></tr><tr><td class="align_left"><tt class="verb">[a-z\d\-.]</tt><tt class="verb">+</tt></td><td class="align_left">英小文字、数字、ハイフン、ドットのいずれかを少なくとも1文字以上繰り返す</td></tr><tr><td class="align_left"><tt class="verb">\.</tt></td><td class="align_left">ドット</td></tr><tr><td class="align_left"><tt class="verb">[a-z]+</tt></td><td class="align_left">英小文字を少なくとも1文字以上繰り返す</td></tr><tr><td class="align_left"><tt class="verb">\z</tt></td><td class="align_left">文字列の末尾</td></tr><tr><td class="align_left"><tt class="verb">/</tt></td><td class="align_left">正規表現の終わりを示す</td></tr><tr><td class="align_left"><tt class="verb">i</tt></td><td class="align_left">大文字小文字を無視するオプション</td></tr></table></div><div class="caption"><span class="header">表6.1</span><span class="description"><a class="ref" href="/chapters/modeling-users.html#code-validates_format_of_email">リスト6.17</a>のメールの正規表現の分解</span></div></div>


<p>ところで、公式標準によるとメールアドレスに完全に一致する正規表現は存在するのだそうです。しかし、苦労して導入するほどの甲斐はありません。<a class="ref" href="/chapters/modeling-users.html#code-validates_format_of_email">リスト6.17</a>の例は問題なく動作しますし、おそらく公式のものより良いでしょう<sup class="footnote" id="fnref-6_12"><a href="/chapters/modeling-users.html#fn-6_12">12</a></sup>。</p>

<div class="label" id="fig-rubular"></div>


<div class="figure"><div class="center"><span class="graphic"><img src="/images/figures/rubular.png" alt="rubular" /></span></div><div class="caption"><span class="header">図6.4</span><span class="description">素晴らしい正規表現エディタ<a href="http://www.rubular.com/">Rubular</a>。<a href="http://railstutorial.org/images/figures/rubular-full.png">(拡大)</a></span></div></div>


<p>これでテストはすべてパスするはずです(実際、この有効なメールアドレスのテストはこれまでいつもパスしてきました。正規表現のプログラミングは間違いが起こりやすいことで有名なので、ここで行なっている有効なメールアドレスのテストは、主として<code>VALID_EMAIL_REGEX</code>に対する形式的な健全性チェックに過ぎません)。残る制約は、メールアドレスが一意であることを強制するものだけとなりました。</p>

<div class="label" id="sec-uniqueness_validation"></div>


<h3><a id="sec-6_2_5" href="/chapters/modeling-users.html#sec-uniqueness_validation" class="heading"><span class="number">6.2.5</span>一意性を検証する</a></h3>


<p>メールアドレスの一意性を強制するために (ユーザー名として使うために)、<code>validates</code>メソッドの<code>:unique</code>オプションを使います。ただしここで<em>重大な</em>警告があります。以下の文面は流し読みせず、必ず注意深く読んでください。</p>

<p>今回もいつものようにテストを作成するところから始めます。モデルのテストではこれまで、主に<code>User.new</code>を使ってきました。このメソッドは単にメモリ上にRubyのオブジェクトを作るだけです。しかし、一意性のテストのためには、メモリ上だけではなく、実際にレコードをデータベースに登録する必要があります<sup class="footnote" id="fnref-6_13"><a href="/chapters/modeling-users.html#fn-6_13">13</a></sup>。(最初の段階の) 重複メールアドレスのテストを<a class="ref" href="/chapters/modeling-users.html#code-validates_uniqueness_of_email_test">リスト6.18</a>に示します。</p>

<div class="label" id="code-validates_uniqueness_of_email_test"></div>


<div class="codelisting">
<div class="listing"><span class="header">リスト6.18</span> <span class="description">重複するメールアドレスの拒否のテスト。</span><br /><span class="description"> <code>spec/models/user_spec.rb</code></span> </div>
<div class="code"><div class="highlight"><pre><span class="nb">require</span> <span class="s1">&#39;spec_helper&#39;</span>

<span class="n">describe</span> <span class="no">User</span> <span class="k">do</span>

  <span class="n">before</span> <span class="k">do</span>
    <span class="vi">@user</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="nb">name</span><span class="p">:</span> <span class="s2">&quot;Example User&quot;</span><span class="p">,</span> <span class="ss">email:</span> <span class="s2">&quot;user@example.com&quot;</span><span class="p">)</span>
  <span class="k">end</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="n">describe</span> <span class="s2">&quot;when email address is already taken&quot;</span> <span class="k">do</span>
    <span class="n">before</span> <span class="k">do</span>
      <span class="n">user_with_same_email</span> <span class="o">=</span> <span class="vi">@user</span><span class="o">.</span><span class="n">dup</span>
      <span class="n">user_with_same_email</span><span class="o">.</span><span class="n">save</span>
    <span class="k">end</span>

    <span class="n">it</span> <span class="p">{</span> <span class="n">should_not</span> <span class="n">be_valid</span> <span class="p">}</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div></div>


<p>上のコードのメソッドは、<code>@user</code>と同じメールアドレスでユーザーを作成します。そのために、<code>@user.dup</code>を使用して同じ属性を持つ重複ユーザーを作ります。次にそのユーザーを保存しようとすると、元の<code>@user</code>のメールアドレスが既にデータベースに存在するため、この重複メールアドレスは無効になるはずです。</p>

<p><a class="ref" href="/chapters/modeling-users.html#code-validates_uniqueness_of_email">リスト6.19</a>のコードをパスする、新しいテストを<a class="ref" href="/chapters/modeling-users.html#code-validates_uniqueness_of_email_test">リスト6.18</a>に示します。</p>

<div class="label" id="code-validates_uniqueness_of_email"></div>


<div class="codelisting">
<div class="listing"><span class="header">リスト6.19</span> <span class="description">メールアドレスの一意性の検査。</span><br /><span class="description"> <code>app/models/user.rb</code></span> </div>
<div class="code"><div class="highlight"><pre><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="ss">ActiveRecord::Base</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="n">validates</span> <span class="ss">:email</span><span class="p">,</span> <span class="ss">presence:</span> <span class="kp">true</span><span class="p">,</span> <span class="nb">format</span><span class="p">:</span> <span class="p">{</span> <span class="ss">with:</span> <span class="no">VALID_EMAIL_REGEX</span> <span class="p">},</span>
                    <span class="ss">uniqueness:</span> <span class="kp">true</span>
<span class="k">end</span>
</pre></div>
</div></div>


<p>実装の途中ですが、ここでひとつ補足します。通常、メールアドレスでは大文字小文字が区別されません。すなわち、<code>foo@bar.com</code>は<code>FOO@BAR.COM</code>や<code>FoO@BAr.coM</code>と書いても扱いは同じです。従って、メールアドレスの検証ではこのような場合も考慮する必要があります<sup class="footnote" id="fnref-6_14"><a href="/chapters/modeling-users.html#fn-6_14">14</a></sup> 。<a class="ref" href="/chapters/modeling-users.html#code-validates_uniqueness_of_email_case_insensitive_test">リスト6.20</a>のコードでは、大文字小文字を区別しないものをテストしています。</p>

<div class="label" id="code-validates_uniqueness_of_email_case_insensitive_test"></div>


<div class="codelisting">
<div class="listing"><span class="header">リスト6.20</span> <span class="description">大文字小文字を区別しない、重複するメールアドレスの拒否のテスト。</span><br /><span class="description"> <code>spec/models/user_spec.rb</code></span> </div>
<div class="code"><div class="highlight"><pre><span class="nb">require</span> <span class="s1">&#39;spec_helper&#39;</span>

<span class="n">describe</span> <span class="no">User</span> <span class="k">do</span>

  <span class="n">before</span> <span class="k">do</span>
    <span class="vi">@user</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="nb">name</span><span class="p">:</span> <span class="s2">&quot;Example User&quot;</span><span class="p">,</span> <span class="ss">email:</span> <span class="s2">&quot;user@example.com&quot;</span><span class="p">)</span>
  <span class="k">end</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="n">describe</span> <span class="s2">&quot;when email address is already taken&quot;</span> <span class="k">do</span>
    <span class="n">before</span> <span class="k">do</span>
      <span class="n">user_with_same_email</span> <span class="o">=</span> <span class="vi">@user</span><span class="o">.</span><span class="n">dup</span>
      <span class="n">user_with_same_email</span><span class="o">.</span><span class="n">email</span> <span class="o">=</span> <span class="vi">@user</span><span class="o">.</span><span class="n">email</span><span class="o">.</span><span class="n">upcase</span>
      <span class="n">user_with_same_email</span><span class="o">.</span><span class="n">save</span>
    <span class="k">end</span>

    <span class="n">it</span> <span class="p">{</span> <span class="n">should_not</span> <span class="n">be_valid</span> <span class="p">}</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div></div>


<p>上のコードではStringの<code>upcase</code>メソッドを使っています (<a class="ref" href="/chapters/rails-flavored-ruby.html#sec-blocks">4.3.2</a>)。このテストは最初のメールアドレスの重複テストと同じことをしていますが、大文字に変換したメールアドレスを使っている点が異なります。もしこのテストが少し抽象的すぎると感じるなら、Railsコンソールを起動して確認しましょう。</p>

<div class="code"><div class="highlight"><pre><span class="go">$ rails console --sandbox</span>
<span class="gp">&gt;&gt; </span><span class="n">user</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="nb">name</span><span class="p">:</span> <span class="s2">&quot;Example User&quot;</span><span class="p">,</span> <span class="ss">email:</span> <span class="s2">&quot;user@example.com&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt; </span><span class="n">user</span><span class="o">.</span><span class="n">email</span><span class="o">.</span><span class="n">upcase</span>
<span class="go">=&gt; &quot;USER@EXAMPLE.COM&quot;</span>
<span class="gp">&gt;&gt; </span><span class="n">user_with_same_email</span> <span class="o">=</span> <span class="n">user</span><span class="o">.</span><span class="n">dup</span>
<span class="gp">&gt;&gt; </span><span class="n">user_with_same_email</span><span class="o">.</span><span class="n">email</span> <span class="o">=</span> <span class="n">user</span><span class="o">.</span><span class="n">email</span><span class="o">.</span><span class="n">upcase</span>
<span class="gp">&gt;&gt; </span><span class="n">user_with_same_email</span><span class="o">.</span><span class="n">valid?</span>
<span class="go">=&gt; true</span>
</pre></div>
</div>


<p>現在の一意性検証では大文字小文字を区別しているため、<code>user_with_same_email.valid?</code>は<code>true</code>になります。しかし、ここでは<code>false</code>になる必要があります。幸い、<code>:uniqueness</code>では<code>:case_sensitive</code>といううってつけのオプションが使用できます (<a class="ref" href="/chapters/modeling-users.html#code-validates_uniqueness_of_email_case_insensitive">リスト6.21</a>)。</p>

<div class="label" id="code-validates_uniqueness_of_email_case_insensitive"></div>


<div class="codelisting">
<div class="listing"><span class="header">リスト6.21</span> <span class="description">メールアドレスの大文字小文字を無視した一意性の検証</span><br /><span class="description"> <code>app/models/user.rb</code></span> </div>
<div class="code"><div class="highlight"><pre><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="ss">ActiveRecord::Base</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="n">validates</span> <span class="ss">:email</span><span class="p">,</span> <span class="ss">presence:</span> <span class="kp">true</span><span class="p">,</span> <span class="nb">format</span><span class="p">:</span> <span class="p">{</span> <span class="ss">with:</span> <span class="no">VALID_EMAIL_REGEX</span> <span class="p">},</span>
                    <span class="ss">uniqueness:</span> <span class="p">{</span> <span class="ss">case_sensitive:</span> <span class="kp">false</span> <span class="p">}</span>
<span class="k">end</span>
</pre></div>
</div></div>


<p>上のコードでは、単に<code>true</code>を<code>case_sensitive: false</code>で置き換えただけであることにご注目ください。Railsはこの場合、<code>:uniqueness</code>を<code>true</code>と判断します。この時点で、アプリケーションは重要な警告と共にメールアドレスの一意性を強制し、テストスイートもパスするはずです。</p>

<div class="label" id="sec-the_caveat"></div>


<h4><a id="sec-6_2_5_1" href="/chapters/modeling-users.html#sec-the_caveat" class="heading">一意性の警告</a></h4>


<p>上で示した警告には、1つ小さな問題があります。</p>

<p><strong><code>validates :uniqueness</code>を使用しても、一意性は保証されません。</strong></p>

<p>えっ！何が問題になるのでしょうか。以下のシナリオを見てください。</p>

<ol>
<li>アリスはサンプルアプリケーションにユーザー登録します。メールアドレスはalice@wonderland.comです。</li>
<li>アリスは誤って “Submit” を素早く<em>2回</em>クリックしてしまいます。そのためリクエストが2つ連続で送信されます。</li>
<li>次のようなことが順に発生します。リクエスト1は、検証にパスするユーザーをメモリー上に作成します。リクエスト2でも同じことが起きます。リクエスト1のユーザーが保存され、リクエスト2のユーザーも保存されます。</li>
<li>この結果、一意性の検証が行われているにもかかわらず、同じメールアドレスを持つ2つのユーザーレコードが作成されてしまいます。</li>
</ol>


<p>上のシナリオが信じがたいもののように思えるかもしれませんが、どうか信じてください。RailsのWebサイトでは、トラフィックが多いときにこのような問題が発生する可能性があるのです。幸い、解決策の実装は簡単です。実は、データベースレベルでも一意性を強制するだけでこの問題は解決します。具体的には、emailカラムにデータベースの<em>インデックス</em>を作成し、そのインデックスが一意であることを要求します。</p>

<p>emailインデックスを追加すると、データモデリングの変更が必要になります。Railsでは (<a class="ref" href="/chapters/modeling-users.html#sec-database_migrations">6.1.1</a>で見たように) マイグレーションでインデックスを追加します。<a class="ref" href="/chapters/modeling-users.html#sec-database_migrations">6.1.1</a>で、Userモデルを生成すると自動的に新しいマイグレーションが作成されたことを思い出してください (<a class="ref" href="/chapters/modeling-users.html#code-users_migration">リスト6.2</a>)。今回の場合は、既に存在するモデルに構造を追加するので、以下のように<code>migration</code>ジェネレーターを使用してマイグレーションを直接作成する必要があります。</p>

<div class="code"><div class="highlight"><pre><span class="gp">$</span> rails generate migration add_index_to_users_email
</pre></div>
</div>


<p>ユーザー用のマイグレーションと異なり、メールアドレスの一意性のマイグレーションは未定義になっています。<a class="ref" href="/chapters/modeling-users.html#code-email_uniqueness_index">リスト6.22</a>のように定義を記述する必要があります<sup class="footnote" id="fnref-6_15"><a href="/chapters/modeling-users.html#fn-6_15">15</a></sup>。</p>

<div class="label" id="code-email_uniqueness_index"></div>


<div class="codelisting">
<div class="listing"><span class="header">リスト6.22</span> <span class="description">メールアドレスの一意性を強制するためのマイグレーション。</span><br /><span class="description"> <code>db/migrate/[timestamp]_add_index_to_users_email.rb</code></span> </div>
<div class="code"><div class="highlight"><pre><span class="k">class</span> <span class="nc">AddIndexToUsersEmail</span> <span class="o">&lt;</span> <span class="ss">ActiveRecord::Migration</span>
  <span class="k">def</span> <span class="nf">change</span>
    <span class="n">add_index</span> <span class="ss">:users</span><span class="p">,</span> <span class="ss">:email</span><span class="p">,</span> <span class="ss">unique:</span> <span class="kp">true</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div></div>


<p>上のコードでは、<code>users</code>テーブルの<code>email</code>カラムにインデックスを追加するために<code>add_index</code>というRailsのメソッドを使っています。インデックス自体は一意性を強制しませんが、オプションで<code>unique: true</code>を指定することで強制できるようになります。</p>

<p>最後に、データベースをマイグレートします。</p>

<div class="code"><div class="highlight"><pre><span class="gp">$</span> bundle <span class="nb">exec </span>rake db:migrate
</pre></div>
</div>


<p>(上のコマンドが失敗した場合は、実行中のサンドボックスのコンソールセッションを終了してみてください。そのセッションがデータベースをロックしてマイグレーションを妨害していた可能性があります)。一意性を強制すると何が起きるかについて関心のある方は、<code>db/schema.rb</code>を開いてみると以下のような行があるはずです。</p>

<div class="code"><div class="highlight"><pre><span class="n">add_index</span> <span class="s2">&quot;users&quot;</span><span class="p">,</span> <span class="o">[</span><span class="s2">&quot;email&quot;</span><span class="o">]</span><span class="p">,</span> <span class="ss">:name</span> <span class="o">=&gt;</span> <span class="s2">&quot;index_users_on_email&quot;</span><span class="p">,</span> <span class="ss">:unique</span> <span class="o">=&gt;</span> <span class="kp">true</span>
</pre></div>
</div>


<p>残念なことに、メールアドレスの一意性を保証するためには、もう1つやらなければならないことがあります。それは、メールアドレスをデータベースに保存する前にすべての文字を小文字に変換することです。その理由は、データベースのアダプタが常に大文字小文字を区別するインデックスを使っているとは限らないからです<sup class="footnote" id="fnref-6_16"><a href="/chapters/modeling-users.html#fn-6_16">16</a></sup>。これを行うには<a href="http://en.wikipedia.org/wiki/Callback_(computer_science)"><em>コールバック</em></a>というテクニックを利用します。コールバックとは、Active Recordオブジェクトが持続している間のどこかの時点で、Active Recordオブジェクトに呼び出してもらうメソッドです (Rails APIの「<a href="http://api.rubyonrails.org/v3.2.0/classes/ActiveRecord/Callbacks.html">コールバックの登録ポイント</a> (英語)」を参照してください)。今回の場合は、<code>before_save</code>コールバックを使います。<a class="ref" href="/chapters/modeling-users.html#code-email_downcase">リスト6.23</a>に示したように、ユーザーをデータベースに保存する前にemail属性を強制的に小文字に変換します。</p>

<div class="label" id="code-email_downcase"></div>


<div class="codelisting">
<div class="listing"><span class="header">リスト6.23</span> <span class="description">email属性を小文字に変換してメールアドレスの一意性を保証する。</span><br /><span class="description"> <code>app/models/user.rb</code></span> </div>
<div class="code"><div class="highlight"><pre><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="ss">ActiveRecord::Base</span> 
  <span class="n">attr_accessible</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">:email</span>

  <span class="n">before_save</span> <span class="p">{</span> <span class="o">|</span><span class="n">user</span><span class="o">|</span> <span class="n">user</span><span class="o">.</span><span class="n">email</span> <span class="o">=</span> <span class="n">email</span><span class="o">.</span><span class="n">downcase</span> <span class="p">}</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
<span class="k">end</span>
</pre></div>
</div></div>


<p><a class="ref" href="/chapters/modeling-users.html#code-email_downcase">リスト6.23</a>のコードは、<code>before_save</code>コールバックにブロックを渡してユーザーのメールアドレスを設定します。設定されるメールアドレスは、現在の値をStringクラスの<code>downcase</code>メソッドを使って小文字バージョンにしたものです。このコードは少し上級者向けなので、今はただ、このコードが動作することを信じてください。それでは気の済まない方は、<a class="ref" href="/chapters/modeling-users.html#code-validates_uniqueness_of_email">リスト6.19</a>から一意性の検証部分をコメントアウトし、重複したメールアドレスを持つユーザーを試しに作成してみれば、エラーが発生するはずです (このテクニックについては<a class="ref" href="/chapters/sign-in-sign-out.html#sec-remember_me">8.2.1</a>でもう一度取り上げます)。</p>

<p>これで、先に述べたアリスのシナリオはうまくいくようになります。データベースは、ユーザーのレコードを最初のリクエストに基づいて保存しますが、次の保存は一意性の制約に反するので拒否します (Railsのログにエラーが出力されますが、害は生じません。ここで発生した<code>ActiveRecord::StatementInvalid</code>例外を実際にキャッチすることもできます。具体例については<a href="http://github.com/insoshi/insoshi/blob/master/app/controllers/people_controller.rb">Insoshi</a>のコードを見てください。ただしこのチュートリアルでは解説しません)。インデックスをemail属性に追加したことで、<a class="ref" href="/chapters/modeling-users.html#sec-finding_user_objects">6.1.4</a>で述べた2番目の目標も達成されます。これは、<code>find_by_email</code>の効率の問題がインデックスによって解決されたためです (<a class="ref" href="/chapters/modeling-users.html#sidebar-database_indices">囲み6.2</a>)。</p>

<div class="label" id="sidebar-database_indices"></div>


<div class="sidebar"><span class="title"><span class="header">囲み6.2</span></span><span class="title"><span class="description">データベースのインデックス</span></span>
<p>データベースにカラムを作成するとき、そのカラムでレコードを<em>検索する (find) </em>必要があるかどうかを考えることは重要です。たとえば、<a class="ref" href="/chapters/modeling-users.html#code-users_migration">リスト6.2</a>のマイグレーションによって作成された<tt>email</tt>属性について考えてみましょう。<a class="ref" href="/chapters/sign-up.html#top">第7章</a>ではユーザーをサンプルアプリにログインできるようにしますが、このとき、送信されたものと一致するメールアドレスのユーザーのレコードをデータベースの中から探しだす必要があります。残念なことに、(インデックスなどの機能を持たない) 素朴なデータモデルにおいてユーザーをメールアドレスで探すには、データベースの<em>ひとりひとりの</em>ユーザーの行を端から順に読み出し、そのemail属性と与えられたメールアドレスを比較するという非効率的な方法しかありません。これは、データベースの世界では<em>全表スキャン</em>として知られており、数千のユーザーがいる実際のサイトでは<a href="http://catb.org/jargon/html/B/Bad-Thing.html">きわめて不都合</a>です。</p>

<p>emailカラムにインデックスを追加することで、この問題を解決することができます。データベースのインデックスを理解するためには、本の索引との類似性を考えるとよいでしょう。本の中で、与えられた言葉 (例えば、“foobar”) が出てくる箇所をすべて見つけるためには、ページを端から順にめくって最後まで探す必要があります。本の索引を利用すれば、“foobar”を含むすべてのページを索引の中から探すだけで済みます。データベースのインデックスも本質的には本の索引と同じように動作します。</p>
</div>




<div class="label" id="sec-adding_a_secure_password"></div>


<h2><a id="sec-6_3" href="/chapters/modeling-users.html#sec-adding_a_secure_password" class="heading"><span class="number">6.3</span>セキュアなパスワードを追加する</a></h2>


<p>この節では、ユーザーに最後の属性を追加します。セキュアパスワードは、サンプルアプリケーションでユーザーを認証するために使用します。セキュアパスワードという手法では、各ユーザーにパスワードとパスワードの確認を入力させ、それを (そのままではなく) 暗号化したものをデータベースに保存します。また、入力されたパスワードを使用してユーザーを<em>認証</em>する手段と、<a class="ref" href="/chapters/sign-in-sign-out.html#top">第8章</a>で使用する、ユーザーがサイトにサインインできるようにする手段も提供します。</p>

<p>ユーザーの認証は、パスワードの送信、暗号化、データベース内の暗号化された値との比較という手順を踏みます。比較の結果が一致すれば、送信されたパスワードは正しいと認識され、そのユーザーは認証されます。ここで、生のパスワードではなく、暗号化されたパスワード同士を比較していることにご注目ください。こうすることで、生のパスワードをデータベースに保存するという危険なことをしなくてもユーザーを認証できます。これで、仮にデータベースの内容が盗まれたり覗き見されるようなことがあっても、パスワードの安全性が保たれます。</p>

<p>セキュアなパスワードの実装は、<code>has_secure_password</code>というRailsのメソッドを呼び出すだけでほとんど終わってしまいます (このメソッドはRails 3.1から導入されました)。このメソッド1つだけでセキュアなパスワードの実装がほとんど終わってしまうので、逆にこの機能を一から手作りするのは簡単ではありません。そのため、<a class="ref" href="/chapters/modeling-users.html#sec-password_and_confirmation">6.3.2</a>からは多数のテストを作成し、これらをすべてパスするようにします。この機能の実装中に泥沼にはまり込んでしまうこともあると思いますが、どうかあきらめずに最後までやり通してください。<a class="ref" href="/chapters/modeling-users.html#sec-has_secure_password">6.3.4</a>までたどり着ければ、その苦労を補って余りある褒美が待っています (スクリーンキャストは、このような一からの手作り開発手順を解説するのに向いています。この課題を十分に理解したい方は「<a href="http://railstutorial.org/screencasts">Ruby on Rails Tutorial screencasts</a> (英語)」を参照してください)。</p>

<div class="label" id="sec-an_encrypted_password"></div>


<h3><a id="sec-6_3_1" href="/chapters/modeling-users.html#sec-an_encrypted_password" class="heading"><span class="number">6.3.1</span>暗号化されたパスワード</a></h3>


<p>最初に、ユーザーのデータモデルに必要な変更を行います。具体的には、<code>users</code>テーブルに<code>password_digest</code>カラムを追加します (<a class="ref" href="/chapters/modeling-users.html#fig-user_model_password_digest">図6.5</a>)。なお、<em>digest</em>という言葉は<a href="http://en.wikipedia.org/wiki/Cryptographic_hash_function">暗号化用ハッシュ関数</a>の用語が語源です。<a class="ref" href="/chapters/modeling-users.html#sec-has_secure_password">6.3.4</a>の実装が動作するには、カラム名を正確に<code>password_digest</code>とする必要があります。パスワードを適切に暗号化することで、たとえ攻撃者によってデータベースからパスワードをコピーされてもWebサイトにサインインされることのないようにできます。</p>

<div class="label" id="fig-user_model_password_digest"></div>


<div class="figure"><div class="center"><span class="graphic"><img src="/images/figures/user_model_password_digest.png" alt="user_model_password_digest" /></span></div><div class="caption"><span class="header">図6.5</span><span class="description">Userモデルに<code>password_digest</code>属性を追加する。</span></div></div>


<p>ハッシュ関数には最新の<a href="http://en.wikipedia.org/wiki/Bcrypt">bcrypt</a>を使用し、パスワードを不可逆的に暗号化してパスワードハッシュを作成します。サンプルアプリケーションでbcryptを使用するために、<code>bcrypt-ruby</code> gemを<code>Gemfile</code>に追加します (<a class="ref" href="/chapters/modeling-users.html#code-bcrypt_ruby">リスト6.24</a>)。</p>

<div class="label" id="code-bcrypt_ruby"></div>


<div class="codelisting">
<div class="listing"><span class="header">リスト6.24</span> <span class="description"><code>bcrypt-ruby</code>を<code>Gemfile</code>に追加する。</span> </div>
<div class="code"><div class="highlight"><pre><span class="n">source</span> <span class="s1">&#39;https://rubygems.org&#39;</span>

<span class="n">gem</span> <span class="s1">&#39;rails&#39;</span><span class="p">,</span> <span class="s1">&#39;3.2.13&#39;</span>
<span class="n">gem</span> <span class="s1">&#39;bootstrap-sass&#39;</span><span class="p">,</span> <span class="s1">&#39;2.1&#39;</span>
<span class="n">gem</span> <span class="s1">&#39;bcrypt-ruby&#39;</span><span class="p">,</span> <span class="s1">&#39;3.0.1&#39;</span>
<span class="o">.</span>
<span class="o">.</span>
<span class="o">.</span>
</pre></div>
</div></div>


<p>次に<code>bundle install</code>を実行します。</p>

<div class="code"><div class="highlight"><pre><span class="gp">$</span> bundle install
</pre></div>
</div>


<p>このとき、システム環境によっては以下の警告が出力されることがあります。</p>

<div class="code"><div class="highlight"><pre><span class="go">make: /usr/bin/gcc-4.2: No such file or directory</span>
</pre></div>
</div>


<p>この問題を修正するには、<code>clang</code>フラグを追加してRVMを再インストールします。</p>

<div class="code"><div class="highlight"><pre><span class="gp">$</span> rvm reinstall 1.9.3 --with-gcc<span class="o">=</span>clang
</pre></div>
</div>


<p>ユーザーはpassword_digestカラムにアクセスしなければならないので、<a class="ref" href="/chapters/modeling-users.html#code-respond_to_password_digest">リスト6.25</a>に示したように、ユーザーオブジェクトは<code>password_digest</code>に応答する必要があります。</p>

<div class="label" id="code-respond_to_password_digest"></div>


<div class="codelisting">
<div class="listing"><span class="header">リスト6.25</span> <span class="description">Userオブジェクトに<code>password_digest</code>カラムがあることを確認するテスト。</span><br /><span class="description"> <code>spec/models/user_spec.rb</code></span> </div>
<div class="code"><div class="highlight"><pre><span class="nb">require</span> <span class="s1">&#39;spec_helper&#39;</span>

<span class="n">describe</span> <span class="no">User</span> <span class="k">do</span>

  <span class="n">before</span> <span class="k">do</span>
    <span class="vi">@user</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="nb">name</span><span class="p">:</span> <span class="s2">&quot;Example User&quot;</span><span class="p">,</span> <span class="ss">email:</span> <span class="s2">&quot;user@example.com&quot;</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="n">subject</span> <span class="p">{</span> <span class="vi">@user</span> <span class="p">}</span>

  <span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">respond_to</span><span class="p">(</span><span class="ss">:name</span><span class="p">)</span> <span class="p">}</span>
  <span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">respond_to</span><span class="p">(</span><span class="ss">:email</span><span class="p">)</span> <span class="p">}</span>
  <span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">respond_to</span><span class="p">(</span><span class="ss">:password_digest</span><span class="p">)</span> <span class="p">}</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
<span class="k">end</span>
</pre></div>
</div></div>


<p>このテストがパスするには、最初に<code>password_digest</code>カラム用の適切なマイグレーションを生成します。</p>

<div class="code"><div class="highlight"><pre><span class="gp">$</span> rails generate migration add_password_digest_to_users password_digest:string
</pre></div>
</div>


<p>上のコマンドの最初の引数はマイグレーション名、次の引数は作成する属性の名前と型です (<a class="ref" href="/chapters/modeling-users.html#code-generate_user_model">リスト6.1</a>で最初に<code>users</code>テーブルを生成したときのマイグレーションと比較してみてください)。マイグレーション名は自由に指定できますが、上のように末尾を<code>_to_users</code>にしておくことをお勧めします。こうしておくと、<code>users</code>テーブルにカラムを追加するマイグレーションがRailsによって自動的に作成されるからです。また、上のコマンドに2番目の引数を与えることで、<a class="ref" href="/chapters/modeling-users.html#code-password_migration">リスト6.26</a>のように完全なマイグレーションを構成するための情報をRailsに与えることができます。</p>

<div class="label" id="code-password_migration"></div>


<div class="codelisting">
<div class="listing"><span class="header">リスト6.26</span> <span class="description"><code>password_digest</code>カラムを<code>users</code>テーブルに追加するマイグレーション。</span><br /><span class="description"> <code>db/migrate/[ts]_add_password_digest_to_users.rb</code></span> </div>
<div class="code"><div class="highlight"><pre><span class="k">class</span> <span class="nc">AddPasswordDigestToUsers</span> <span class="o">&lt;</span> <span class="ss">ActiveRecord::Migration</span>
  <span class="k">def</span> <span class="nf">change</span>
    <span class="n">add_column</span> <span class="ss">:users</span><span class="p">,</span> <span class="ss">:password_digest</span><span class="p">,</span> <span class="ss">:string</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div></div>


<p>上のコードでは、<code>add_column</code>メソッドを使用して<code>password_digest</code> カラムを<code>users</code>テーブルに追加しています。</p>

<p>以下のように開発データベースをマイグレーションしてテストデータベースを準備することで、<a class="ref" href="/chapters/modeling-users.html#code-respond_to_password_digest">リスト6.25</a>の失敗するテストをパスすることができます。</p>

<div class="code"><div class="highlight"><pre><span class="gp">$</span> bundle <span class="nb">exec </span>rake db:migrate
<span class="gp">$</span> bundle <span class="nb">exec </span>rake db:test:prepare
<span class="gp">$</span> bundle <span class="nb">exec </span>rspec spec/
</pre></div>
</div>




<div class="label" id="sec-password_and_confirmation"></div>


<h3><a id="sec-6_3_2" href="/chapters/modeling-users.html#sec-password_and_confirmation" class="heading"><span class="number">6.3.2</span>パスワードと確認</a></h3>


<p><a class="ref" href="/chapters/modeling-users.html#fig-signup_mockup_preview">図6.1</a>のモックアップに示したように、ユーザーにパスワードを確認させるようにしましょう。パスワードの確認入力は、入力ミスを減らすためにWebで広く使用されています。パスワード確認の強制はコントローラの階層でも行うことができますが、モデルの中でActive Recordを使用して制限を与えるのが慣習になっています。そのためには、<code>password</code>属性と<code>password_confirmation</code>属性をUserモデルに追加し、レコードをデータベースに保存する前に2つの属性が一致するように要求します。これまでに使用した属性と異なり、パスワード関連の属性は<em>仮想</em>にします。つまり、これらの属性は一時的にメモリ上に置き、データベースには保存されないようにします。<a class="ref" href="/chapters/modeling-users.html#sec-has_secure_password">6.3.4</a>でも説明しますが、これらの仮想属性は<code>has_secure_password</code>では自動的に実装されます。</p>

<p>最初に、<code>respond_to</code>を使用してパスワードとパスワードの確認を<a class="ref" href="/chapters/modeling-users.html#code-user_respond_to_password">リスト6.27</a>のようにテストします。</p>

<div class="label" id="code-user_respond_to_password"></div>


<div class="codelisting">
<div class="listing"><span class="header">リスト6.27</span> <span class="description"><code>password</code>属性と<code>password_confirmation</code>属性をテストする。</span><br /><span class="description"> <code>spec/models/user_spec.rb</code></span> </div>
<div class="code"><div class="highlight"><pre><span class="nb">require</span> <span class="s1">&#39;spec_helper&#39;</span>

<span class="n">describe</span> <span class="no">User</span> <span class="k">do</span>

  <span class="n">before</span> <span class="k">do</span>
    <span class="vi">@user</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="nb">name</span><span class="p">:</span> <span class="s2">&quot;Example User&quot;</span><span class="p">,</span> <span class="ss">email:</span> <span class="s2">&quot;user@example.com&quot;</span><span class="p">,</span> 
                     <span class="ss">password:</span> <span class="s2">&quot;foobar&quot;</span><span class="p">,</span> <span class="ss">password_confirmation:</span> <span class="s2">&quot;foobar&quot;</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="n">subject</span> <span class="p">{</span> <span class="vi">@user</span> <span class="p">}</span>

  <span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">respond_to</span><span class="p">(</span><span class="ss">:name</span><span class="p">)</span> <span class="p">}</span>
  <span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">respond_to</span><span class="p">(</span><span class="ss">:email</span><span class="p">)</span> <span class="p">}</span>
  <span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">respond_to</span><span class="p">(</span><span class="ss">:password_digest</span><span class="p">)</span> <span class="p">}</span>
  <span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">respond_to</span><span class="p">(</span><span class="ss">:password</span><span class="p">)</span> <span class="p">}</span>
  <span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">respond_to</span><span class="p">(</span><span class="ss">:password_confirmation</span><span class="p">)</span> <span class="p">}</span>

  <span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">be_valid</span> <span class="p">}</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
<span class="k">end</span>
</pre></div>
</div></div>


<p>上のコードでは、以下のように<code>User.new</code>ハッシュの初期化に<code>:password</code>と<code>:password_confirmation</code>を追加していることにご注目ください。</p>

<div class="code"><div class="highlight"><pre><span class="n">before</span> <span class="k">do</span>
  <span class="vi">@user</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="nb">name</span><span class="p">:</span> <span class="s2">&quot;Example User&quot;</span><span class="p">,</span> <span class="ss">email:</span> <span class="s2">&quot;user@example.com&quot;</span><span class="p">,</span> 
                   <span class="ss">password:</span> <span class="s2">&quot;foobar&quot;</span><span class="p">,</span> <span class="ss">password_confirmation:</span> <span class="s2">&quot;foobar&quot;</span><span class="p">)</span>
<span class="k">end</span>
</pre></div>
</div>


<p>パスワードは空欄であってはならないので、パスワードの存在確認テストを別に追加します。</p>

<div class="code"><div class="highlight"><pre><span class="n">describe</span> <span class="s2">&quot;when password is not present&quot;</span> <span class="k">do</span>
  <span class="n">before</span> <span class="p">{</span> <span class="vi">@user</span><span class="o">.</span><span class="n">password</span> <span class="o">=</span> <span class="vi">@user</span><span class="o">.</span><span class="n">password_confirmation</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span> <span class="p">}</span>
  <span class="n">it</span> <span class="p">{</span> <span class="n">should_not</span> <span class="n">be_valid</span> <span class="p">}</span>
<span class="k">end</span>
</pre></div>
</div>


<p>パスワードの不一致テストはこのすぐ後に追加するので、上のコードではパスワードとパスワードの確認を両方とも空欄にすることでパスワードの<em>存在</em>確認テストを行なっています。ここでは、1つの行でいくつもの代入を行えるRubyの機能を使用しています。たとえば、以下のようにコンソール上で<code>a</code>と<code>b</code>に<code>3</code>を一括で代入することができます。</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt; </span><span class="n">a</span>
<span class="go">=&gt; 3</span>
<span class="gp">&gt;&gt; </span><span class="n">b</span>
<span class="go">=&gt; 3</span>
</pre></div>
</div>


<p>この機能を使用して、ここでは以下のように2つのパスワード関連の属性をどちらも<code>&quot; &quot;</code>に設定しています。</p>

<div class="code"><div class="highlight"><pre><span class="vi">@user</span><span class="o">.</span><span class="n">password</span> <span class="o">=</span> <span class="vi">@user</span><span class="o">.</span><span class="n">password_confirmation</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span>
</pre></div>
</div>


<p>パスワードとパスワードの確認が一致するかどうかもテストする必要があります。パスワードが一致<em>する</em>場合については既に<code>it { should be_valid }</code>で確認できるので、次は以下のように不一致の場合のテストを追加します。</p>

<div class="code"><div class="highlight"><pre><span class="n">describe</span> <span class="s2">&quot;when password doesn&#39;t match confirmation&quot;</span> <span class="k">do</span>
  <span class="n">before</span> <span class="p">{</span> <span class="vi">@user</span><span class="o">.</span><span class="n">password_confirmation</span> <span class="o">=</span> <span class="s2">&quot;mismatch&quot;</span> <span class="p">}</span>
  <span class="n">it</span> <span class="p">{</span> <span class="n">should_not</span> <span class="n">be_valid</span> <span class="p">}</span>
<span class="k">end</span>
</pre></div>
</div>


<p>原理的にはテストは以上で終わりですが、しかしまだカバーされていない状態があります。パスワードの確認が空欄の場合はどうなるでしょうか。「パスワードの確認がスペース文字だがパスワードは有効」な場合、両者は一致しないのでパスワードの確認の検証で検出されます。「パスワードとパスワードの確認がどちらもスペース文字」の場合、パスワードの存在確認テストで検出されます。残念ながら、1つだけ漏れがあります。それは、パスワードの確認が<em>nil</em>の場合です。この状態はWebからの入力では決して発生しませんが、コンソールでなら以下のように発生させることができます。</p>

<div class="code"><div class="highlight"><pre><span class="go">$ rails console</span>
<span class="gp">&gt;&gt; </span><span class="no">User</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="nb">name</span><span class="p">:</span> <span class="s2">&quot;Michael Hartl&quot;</span><span class="p">,</span> <span class="ss">email:</span> <span class="s2">&quot;mhartl@example.com&quot;</span><span class="p">,</span>
<span class="gp">?</span><span class="gp">&gt; </span>            <span class="ss">password:</span> <span class="s2">&quot;foobar&quot;</span><span class="p">,</span> <span class="ss">password_confirmation:</span> <span class="kp">nil</span><span class="p">)</span>
</pre></div>
</div>


<p>パスワードの確認が<code>nil</code>の場合、パスワードの確認の検証はRailsによって実行されません。つまり、コンソール上でならパスワードの確認を回避してユーザーを作成できてしまうということです (もちろん、<em>現時点では</em>検証をそもそも実装していないので、実際には上のコードはすべて動作してしまいます) 。この状態を防ぐには、nilを検出できるテストを追加します。</p>

<div class="code"><div class="highlight"><pre><span class="n">describe</span> <span class="s2">&quot;when password confirmation is nil&quot;</span> <span class="k">do</span>
  <span class="n">before</span> <span class="p">{</span> <span class="vi">@user</span><span class="o">.</span><span class="n">password_confirmation</span> <span class="o">=</span> <span class="kp">nil</span> <span class="p">}</span>
  <span class="n">it</span> <span class="p">{</span> <span class="n">should_not</span> <span class="n">be_valid</span> <span class="p">}</span>
<span class="k">end</span>
</pre></div>
</div>


<p>(この振る舞いは、Railsのマイナーなバグであると思います。おそらく今後のバージョンで修正されるでしょう。いずれの場合も、nilの検証を加えることで問題は生じません)。</p>

<p>ここまでのすべてを盛り込んだ失敗するテストを<a class="ref" href="/chapters/modeling-users.html#code-password_tests">リスト6.28</a>に示します。この節の冒頭で述べたように、<code>has_secure_password</code>には多くの機能が含まれているため、セキュアパスワードを手作りで実装するのは簡単ではありません。従って、この時点では新しいテストはすべて失敗します。<a class="ref" href="/chapters/modeling-users.html#sec-has_secure_password">6.3.4</a>でこれらのテストがパスするようにします。</p>

<div class="label" id="code-password_tests"></div>


<div class="codelisting">
<div class="listing"><span class="header">リスト6.28</span> <span class="description">パスワードとパスワードの確認をテストする。</span><br /><span class="description"> <code>spec/models/user_spec.rb</code></span> </div>
<div class="code"><div class="highlight"><pre><span class="nb">require</span> <span class="s1">&#39;spec_helper&#39;</span>

<span class="n">describe</span> <span class="no">User</span> <span class="k">do</span>

  <span class="n">before</span> <span class="k">do</span>
    <span class="vi">@user</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="nb">name</span><span class="p">:</span> <span class="s2">&quot;Example User&quot;</span><span class="p">,</span> <span class="ss">email:</span> <span class="s2">&quot;user@example.com&quot;</span><span class="p">,</span> 
                     <span class="ss">password:</span> <span class="s2">&quot;foobar&quot;</span><span class="p">,</span> <span class="ss">password_confirmation:</span> <span class="s2">&quot;foobar&quot;</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="n">subject</span> <span class="p">{</span> <span class="vi">@user</span> <span class="p">}</span>

  <span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">respond_to</span><span class="p">(</span><span class="ss">:name</span><span class="p">)</span> <span class="p">}</span>
  <span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">respond_to</span><span class="p">(</span><span class="ss">:email</span><span class="p">)</span> <span class="p">}</span>
  <span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">respond_to</span><span class="p">(</span><span class="ss">:password_digest</span><span class="p">)</span> <span class="p">}</span>
  <span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">respond_to</span><span class="p">(</span><span class="ss">:password</span><span class="p">)</span> <span class="p">}</span>
  <span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">respond_to</span><span class="p">(</span><span class="ss">:password_confirmation</span><span class="p">)</span> <span class="p">}</span>

  <span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">be_valid</span> <span class="p">}</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="n">describe</span> <span class="s2">&quot;when password is not present&quot;</span> <span class="k">do</span>
    <span class="n">before</span> <span class="p">{</span> <span class="vi">@user</span><span class="o">.</span><span class="n">password</span> <span class="o">=</span> <span class="vi">@user</span><span class="o">.</span><span class="n">password_confirmation</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span> <span class="p">}</span>
    <span class="n">it</span> <span class="p">{</span> <span class="n">should_not</span> <span class="n">be_valid</span> <span class="p">}</span>
  <span class="k">end</span>

  <span class="n">describe</span> <span class="s2">&quot;when password doesn&#39;t match confirmation&quot;</span> <span class="k">do</span>
    <span class="n">before</span> <span class="p">{</span> <span class="vi">@user</span><span class="o">.</span><span class="n">password_confirmation</span> <span class="o">=</span> <span class="s2">&quot;mismatch&quot;</span> <span class="p">}</span>
    <span class="n">it</span> <span class="p">{</span> <span class="n">should_not</span> <span class="n">be_valid</span> <span class="p">}</span>
  <span class="k">end</span>

  <span class="n">describe</span> <span class="s2">&quot;when password confirmation is nil&quot;</span> <span class="k">do</span>
    <span class="n">before</span> <span class="p">{</span> <span class="vi">@user</span><span class="o">.</span><span class="n">password_confirmation</span> <span class="o">=</span> <span class="kp">nil</span> <span class="p">}</span>
    <span class="n">it</span> <span class="p">{</span> <span class="n">should_not</span> <span class="n">be_valid</span> <span class="p">}</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div></div>




<div class="label" id="sec-user_authentication"></div>


<h3><a id="sec-6_3_3" href="/chapters/modeling-users.html#sec-user_authentication" class="heading"><span class="number">6.3.3</span>ユーザー認証</a></h3>


<p>パスワード機構というパズルの最後のひとかけらは、ユーザーをメールアドレスとパスワードに基いて取得する手段です。この作業は2つに分けるのが自然です。最初に、ユーザーをメールアドレスで検索します。次に、受け取ったパスワードでユーザーを認証します。</p>

<p>最初の手順の実装は簡単です。<a class="ref" href="/chapters/modeling-users.html#sec-finding_user_objects">6.1.4</a>でも説明したように、<code>find_by_email</code>メソッドを使用すれば、受け取ったメールアドレスでユーザーを検索できます。</p>

<div class="code"><div class="highlight"><pre><span class="n">user</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">find_by_email</span><span class="p">(</span><span class="n">email</span><span class="p">)</span>
</pre></div>
</div>


<p>次の手順は、<code>authenticate</code>メソッドを使用して、受け取ったパスワードがユーザーのパスワードと一致することを確認します。<a class="ref" href="/chapters/sign-in-sign-out.html#top">第8章</a>では、以下のようなコードを使用して現在の (サインインしている) ユーザーを取得する予定です。</p>

<div class="code"><div class="highlight"><pre><span class="n">current_user</span> <span class="o">=</span> <span class="n">user</span><span class="o">.</span><span class="n">authenticate</span><span class="p">(</span><span class="n">password</span><span class="p">)</span>
</pre></div>
</div>


<p>受け取ったパスワードがユーザーのパスワードと一致するとユーザーが返され、一致しない場合は<code>false</code>が返されます。</p>

<p>これまで同様、RSpecを使用して<code>authenticate</code>メソッドへの要求内容を表現することができます。ただし、このテストはこれまでよりも高度な内容になるため、いくつかに分割して説明します。RSpecが初めての方は、この節を繰り返し読んでみてください。最初に、Userオブジェクトが<code>authenticate</code>に応答することを要求します。</p>

<div class="code"><div class="highlight"><pre><span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">respond_to</span><span class="p">(</span><span class="ss">:authenticate</span><span class="p">)</span> <span class="p">}</span>
</pre></div>
</div>


<p>次に、パスワードが一致する場合と一致しない場合についてそれぞれ記述します。</p>

<div class="code"><div class="highlight"><pre><span class="n">describe</span> <span class="s2">&quot;return value of authenticate method&quot;</span> <span class="k">do</span>
  <span class="n">before</span> <span class="p">{</span> <span class="vi">@user</span><span class="o">.</span><span class="n">save</span> <span class="p">}</span>
  <span class="n">let</span><span class="p">(</span><span class="ss">:found_user</span><span class="p">)</span> <span class="p">{</span> <span class="no">User</span><span class="o">.</span><span class="n">find_by_email</span><span class="p">(</span><span class="vi">@user</span><span class="o">.</span><span class="n">email</span><span class="p">)</span> <span class="p">}</span>

  <span class="n">describe</span> <span class="s2">&quot;with valid password&quot;</span> <span class="k">do</span>
    <span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="o">==</span> <span class="n">found_user</span><span class="o">.</span><span class="n">authenticate</span><span class="p">(</span><span class="vi">@user</span><span class="o">.</span><span class="n">password</span><span class="p">)</span> <span class="p">}</span>
  <span class="k">end</span>

  <span class="n">describe</span> <span class="s2">&quot;with invalid password&quot;</span> <span class="k">do</span>
    <span class="n">let</span><span class="p">(</span><span class="ss">:user_for_invalid_password</span><span class="p">)</span> <span class="p">{</span> <span class="n">found_user</span><span class="o">.</span><span class="n">authenticate</span><span class="p">(</span><span class="s2">&quot;invalid&quot;</span><span class="p">)</span> <span class="p">}</span>

    <span class="n">it</span> <span class="p">{</span> <span class="n">should_not</span> <span class="o">==</span> <span class="n">user_for_invalid_password</span> <span class="p">}</span>
    <span class="n">specify</span> <span class="p">{</span> <span class="n">user_for_invalid_password</span><span class="o">.</span><span class="n">should</span> <span class="n">be_false</span> <span class="p">}</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>


<p>上のコードで、<code>before</code>ブロックはユーザーをデータベースに事前に保存します。これにより、<code>find_by_email</code>メソッドが動作するようになります。このメソッドを<code>let</code>メソッドで以下のようにテストします。</p>

<div class="code"><div class="highlight"><pre><span class="n">let</span><span class="p">(</span><span class="ss">:found_user</span><span class="p">)</span> <span class="p">{</span> <span class="no">User</span><span class="o">.</span><span class="n">find_by_email</span><span class="p">(</span><span class="vi">@user</span><span class="o">.</span><span class="n">email</span><span class="p">)</span> <span class="p">}</span>
</pre></div>
</div>


<p>これまでいくつかの演習で<code>let</code>メソッドを使用してきましたが、今回のようにチュートリアルの本文で言及するのはこれが初めてです。<code>let</code>メソッドの詳細については<a class="ref" href="/chapters/modeling-users.html#sidebar-let">囲み6.3</a>を参照してください。</p>

<p>2つの<code>describe</code>ブロックでは、<code>@user</code>と<code>found_user</code>が一致する場合と一致しない場合についてそれぞれテストします。コードで使用されている二重等号の演算子<code>==</code>は、オブジェクト同士が同値であるかどうかを調べます(<a class="ref" href="/chapters/rails-flavored-ruby.html#sec-arrays_and_ranges">4.3.1</a>)。以下のコードにご注目ください。</p>

<div class="code"><div class="highlight"><pre><span class="n">describe</span> <span class="s2">&quot;with invalid password&quot;</span> <span class="k">do</span>
  <span class="n">let</span><span class="p">(</span><span class="ss">:user_for_invalid_password</span><span class="p">)</span> <span class="p">{</span> <span class="n">found_user</span><span class="o">.</span><span class="n">authenticate</span><span class="p">(</span><span class="s2">&quot;invalid&quot;</span><span class="p">)</span> <span class="p">}</span>

  <span class="n">it</span> <span class="p">{</span> <span class="n">should_not</span> <span class="o">==</span> <span class="n">user_for_invalid_password</span> <span class="p">}</span>   
  <span class="n">specify</span> <span class="p">{</span> <span class="n">user_for_invalid_password</span><span class="o">.</span><span class="n">should</span> <span class="n">be_false</span> <span class="p">}</span>
<span class="k">end</span>
</pre></div>
</div>


<p>上のコードでは<code>let</code>がもう一度使用されており、さらに<code>specify</code>というメソッドも使用されています。実は、このspecifyは<code>it</code>と同義であり、<code>it</code>を使用すると英語として不自然な場合にこれで代用することができます。この場合、「it should not equal wrong user」(itはユーザーなど) とするのは英語として自然ですが、「user: user with invalid password should be false」は不自然であり、「specify: user with invalid password should be false」とすれば自然になります。</p>

<div class="label" id="sidebar-let"></div>


<div class="sidebar"><span class="title"><span class="header">囲み6.3</span></span><span class="title"><span class="description"><tt>let</tt>メソッド</span></span>
<p>RSpecの<tt>let</tt>メソッドを使用すると、テスト内で簡単にローカル変数を作成することができます。文法は一見奇妙ですが、動作は変数への割り当てと似ています。<tt>let</tt>の引数はシンボルであり、さらにブロックを引数に取ります。そのブロックは、このシンボル名を持つローカル変数に値を返します。つまり、以下のコードを実行すると、</p>

<pre class="verbatim">let(:found_user) { User.find_by_email(@user.email) }</pre>


<p><tt>found_user</tt>という変数が作成され、その値は<tt>find_by_email</tt>の返し値に等しくなります。これにより、この変数はテスト中すべての<tt>before</tt>または<tt>it</tt>ブロックで利用できるようになります。<tt>let</tt>では値が<em>メモ化 (memoize) </em>されるという特長があり、ある呼び出しから次の呼び出しに渡って値を利用できます (<a href="http://en.wikipedia.org/wiki/Memoization"><em>メモ化</em></a>は技術用語であり、決して &quot;memorize&quot; の誤りでは<em>ありません</em>) 。この場合、<tt>found_user</tt>変数は<tt>let</tt>によってメモ化され、<tt>find_by_email</tt>が実際に呼び出されるのはUserモデルのspecが実際に実行されるときだけとなります。</p>
</div>


<p>最後に、セキュリティの常道として、パスワードの長さ検証をテストします。以下のコードでは、パスワードは6文字以上であることを要求します。</p>

<div class="code"><div class="highlight"><pre><span class="n">describe</span> <span class="s2">&quot;with a password that&#39;s too short&quot;</span> <span class="k">do</span>
  <span class="n">before</span> <span class="p">{</span> <span class="vi">@user</span><span class="o">.</span><span class="n">password</span> <span class="o">=</span> <span class="vi">@user</span><span class="o">.</span><span class="n">password_confirmation</span> <span class="o">=</span> <span class="s2">&quot;a&quot;</span> <span class="o">*</span> <span class="mi">5</span> <span class="p">}</span>
  <span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">be_invalid</span> <span class="p">}</span>
<span class="k">end</span>
</pre></div>
</div>


<p>ここまでのテストをすべて集約したものを<a class="ref" href="/chapters/modeling-users.html#code-authenticate_spec">リスト6.29</a>に示します。</p>

<div class="label" id="code-authenticate_spec"></div>


<div class="codelisting">
<div class="listing"><span class="header">リスト6.29</span> <span class="description"><code>authenticate</code>メソッドをテストする。</span><br /><span class="description"> <code>spec/models/user_spec.rb</code></span> </div>
<div class="code"><div class="highlight"><pre><span class="nb">require</span> <span class="s1">&#39;spec_helper&#39;</span>

<span class="n">describe</span> <span class="no">User</span> <span class="k">do</span>

  <span class="n">before</span> <span class="k">do</span>
    <span class="vi">@user</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="nb">name</span><span class="p">:</span> <span class="s2">&quot;Example User&quot;</span><span class="p">,</span> <span class="ss">email:</span> <span class="s2">&quot;user@example.com&quot;</span><span class="p">,</span> 
                     <span class="ss">password:</span> <span class="s2">&quot;foobar&quot;</span><span class="p">,</span> <span class="ss">password_confirmation:</span> <span class="s2">&quot;foobar&quot;</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="n">subject</span> <span class="p">{</span> <span class="vi">@user</span> <span class="p">}</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">respond_to</span><span class="p">(</span><span class="ss">:authenticate</span><span class="p">)</span> <span class="p">}</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="n">describe</span> <span class="s2">&quot;with a password that&#39;s too short&quot;</span> <span class="k">do</span>
    <span class="n">before</span> <span class="p">{</span> <span class="vi">@user</span><span class="o">.</span><span class="n">password</span> <span class="o">=</span> <span class="vi">@user</span><span class="o">.</span><span class="n">password_confirmation</span> <span class="o">=</span> <span class="s2">&quot;a&quot;</span> <span class="o">*</span> <span class="mi">5</span> <span class="p">}</span>
    <span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">be_invalid</span> <span class="p">}</span>
  <span class="k">end</span>

  <span class="n">describe</span> <span class="s2">&quot;return value of authenticate method&quot;</span> <span class="k">do</span>
    <span class="n">before</span> <span class="p">{</span> <span class="vi">@user</span><span class="o">.</span><span class="n">save</span> <span class="p">}</span>
    <span class="n">let</span><span class="p">(</span><span class="ss">:found_user</span><span class="p">)</span> <span class="p">{</span> <span class="no">User</span><span class="o">.</span><span class="n">find_by_email</span><span class="p">(</span><span class="vi">@user</span><span class="o">.</span><span class="n">email</span><span class="p">)</span> <span class="p">}</span>

    <span class="n">describe</span> <span class="s2">&quot;with valid password&quot;</span> <span class="k">do</span>
      <span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="o">==</span> <span class="n">found_user</span><span class="o">.</span><span class="n">authenticate</span><span class="p">(</span><span class="vi">@user</span><span class="o">.</span><span class="n">password</span><span class="p">)</span> <span class="p">}</span>
    <span class="k">end</span>

    <span class="n">describe</span> <span class="s2">&quot;with invalid password&quot;</span> <span class="k">do</span>
      <span class="n">let</span><span class="p">(</span><span class="ss">:user_for_invalid_password</span><span class="p">)</span> <span class="p">{</span> <span class="n">found_user</span><span class="o">.</span><span class="n">authenticate</span><span class="p">(</span><span class="s2">&quot;invalid&quot;</span><span class="p">)</span> <span class="p">}</span>

      <span class="n">it</span> <span class="p">{</span> <span class="n">should_not</span> <span class="o">==</span> <span class="n">user_for_invalid_password</span> <span class="p">}</span>
      <span class="n">specify</span> <span class="p">{</span> <span class="n">user_for_invalid_password</span><span class="o">.</span><span class="n">should</span> <span class="n">be_false</span> <span class="p">}</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div></div>


<p><a class="ref" href="/chapters/modeling-users.html#sidebar-let">囲み6.3</a>で解説したように<code>let</code>では値がメモ化されます。これにより、<a class="ref" href="/chapters/modeling-users.html#code-authenticate_spec">リスト6.29</a>にある、最初のネストしている<code>describe</code>ブロックは<code>let</code>で<code>find_by_email</code>を使用してデータベースからユーザーを取得します。しかしその次のネストしている<code>describe</code>ブロックは (メモ化された値を利用するので) データベースにアクセスしません。</p>

<div class="label" id="sec-has_secure_password"></div>


<h3><a id="sec-6_3_4" href="/chapters/modeling-users.html#sec-has_secure_password" class="heading"><span class="number">6.3.4</span>ユーザーがセキュアなパスワードを持っている</a></h3>


<p>認証システムを最初からフル作成していた<a href="http://railstutorial.org/book?version=3.0">Rails 3.0向け<em>Railsチュートリアル</em></a><sup class="footnote" id="fnref-6_17"><a href="/chapters/modeling-users.html#fn-6_17">17</a></sup>を参照いただくとわかるように、以前のバージョンのRailsでは、セキュアパスワードの実装は面倒で時間のかかる作業でした。しかし今では、Web開発者が認証システムというものを以前よりも深く理解するようになり、最新のRailsには認証システムも同梱されるようになりました。ここまで実装を進めてきたので、あとほんの数行を追加してセキュアパスワードの実装を完了し、テストスイートを緑色 (成功) にしましょう。</p>

<p>最初に、<code>password</code>カラムと<code>password_confirmation</code>カラムをアクセス可能にし (<a class="ref" href="/chapters/modeling-users.html#sec-accessible_attributes">6.1.2.2</a>)、新しいユーザーを初期化ハッシュでインスタンス化できるようにします。</p>

<div class="code"><div class="highlight"><pre><span class="vi">@user</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="nb">name</span><span class="p">:</span> <span class="s2">&quot;Example User&quot;</span><span class="p">,</span> <span class="ss">email:</span> <span class="s2">&quot;user@example.com&quot;</span><span class="p">,</span> 
                 <span class="ss">password:</span> <span class="s2">&quot;foobar&quot;</span><span class="p">,</span> <span class="ss">password_confirmation:</span> <span class="s2">&quot;foobar&quot;</span><span class="p">)</span>
</pre></div>
</div>


<p><a class="ref" href="/chapters/modeling-users.html#code-attr_accessible">リスト6.6</a>のモデルに従い、適切なシンボルをアクセス可能な属性のリストに以下のように追加します。</p>

<div class="code"><div class="highlight"><pre><span class="n">attr_accessible</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">:email</span><span class="p">,</span> <span class="ss">:password</span><span class="p">,</span> <span class="ss">:password_confirmation</span>
</pre></div>
</div>


<p>次に、パスワードの存在確認と長さチェックが必要です。後者の実装には、<a class="ref" href="/chapters/modeling-users.html#code-length_validation">6.15</a>の<code>:maximum</code>キーに似た<code>:minimum</code>キーを使用します。</p>

<div class="code"><div class="highlight"><pre><span class="n">validates</span> <span class="ss">:password</span><span class="p">,</span> <span class="ss">presence:</span> <span class="kp">true</span><span class="p">,</span> <span class="ss">length:</span> <span class="p">{</span> <span class="ss">minimum:</span> <span class="mi">6</span> <span class="p">}</span>
</pre></div>
</div>


<p>次に、<code>password</code>属性と<code>password_confirmation</code>属性を追加し、パスワードが存在することを要求し、パスワードとパスワードの確認が一致することを要求し、さらに<code>authenticate</code>メソッドを使用して、暗号化されたパスワードと<code>password_digest</code>を比較してユーザーを認証するという多くの手順が必要です。この実装が唯一手間のかかる箇所ですが、最新のRailsでは<code>has_secure_password</code>を使用するだけでこれらの機能をすべて自由に利用できます。</p>

<div class="code"><div class="highlight"><pre><span class="n">has_secure_password</span>
</pre></div>
</div>


<p>データベースに<code>password_digest</code>カラムを置くという条件さえ守れば、上のメソッドをモデルに追加するだけで新規ユーザーの作成と認証をセキュアにすることができます。</p>

<p>(<code>has_secure_password</code>の実装に興味のある方は、<a href="https://github.com/rails/rails/blob/master/activemodel/lib/active_model/secure_password.rb"><tt>secure_password.rb</tt>のソースコード</a>を参照してみるとよいでしょう。このソースコードには十分な解説があり、しかも読みやすくできています。そのコードに、以下の行があることにご注目ください。</p>

<div class="code"><div class="highlight"><pre><span class="n">validates_confirmation_of</span> <span class="ss">:password</span>
</pre></div>
</div>


<p>上のコードを実行するだけで、(<a href="http://api.rubyonrails.org/v3.2.0/classes/ActiveModel/Validations/HelperMethods.html#method-i-validates_confirmation_of">Rails API</a>に記載されているように) <code>password_confirmation</code>という属性が作成されます。このコードには<code>password_digest</code>属性の検証も含まれますが、<a class="ref" href="/chapters/sign-up.html#top">第7章</a>ではこれがいいことばかりとは限らないことをお見せします)</p>

<p>最後に、パスワードの確認について存在チェックを行います。</p>

<div class="code"><div class="highlight"><pre><span class="n">validates</span> <span class="ss">:password_confirmation</span><span class="p">,</span> <span class="ss">presence:</span> <span class="kp">true</span>
</pre></div>
</div>


<p>これらの3つの要素をすべて反映したUserモデルを<a class="ref" href="/chapters/modeling-users.html#code-password_implementation">リスト6.30</a>に示します。これでセキュアパスワードの実装は完了です。</p>

<div class="label" id="code-password_implementation"></div>


<div class="codelisting">
<div class="listing"><span class="header">リスト6.30</span> <span class="description">セキュアパスワードの完全な実装。</span><br /><span class="description"> <code>app/models/user.rb</code></span> </div>
<div class="code"><div class="highlight"><pre><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="ss">ActiveRecord::Base</span>
  <span class="n">attr_accessible</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">:email</span><span class="p">,</span> <span class="ss">:password</span><span class="p">,</span> <span class="ss">:password_confirmation</span>
  <span class="n">has_secure_password</span>

  <span class="n">before_save</span> <span class="p">{</span> <span class="o">|</span><span class="n">user</span><span class="o">|</span> <span class="n">user</span><span class="o">.</span><span class="n">email</span> <span class="o">=</span> <span class="n">email</span><span class="o">.</span><span class="n">downcase</span> <span class="p">}</span>

  <span class="n">validates</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">presence:</span> <span class="kp">true</span><span class="p">,</span> <span class="ss">length:</span> <span class="p">{</span> <span class="ss">maximum:</span> <span class="mi">50</span> <span class="p">}</span>
  <span class="no">VALID_EMAIL_REGEX</span> <span class="o">=</span> <span class="sr">/\A[\w+\-.]+@[a-z\d\-.]</span><span class="sr">+\.[a-z]+\z/i</span>
  <span class="n">validates</span> <span class="ss">:email</span><span class="p">,</span> <span class="ss">presence:</span>   <span class="kp">true</span><span class="p">,</span>
                    <span class="nb">format</span><span class="p">:</span>     <span class="p">{</span> <span class="ss">with:</span> <span class="no">VALID_EMAIL_REGEX</span> <span class="p">},</span>
                    <span class="ss">uniqueness:</span> <span class="p">{</span> <span class="ss">case_sensitive:</span> <span class="kp">false</span> <span class="p">}</span>
  <span class="n">validates</span> <span class="ss">:password</span><span class="p">,</span> <span class="ss">presence:</span> <span class="kp">true</span><span class="p">,</span> <span class="ss">length:</span> <span class="p">{</span> <span class="ss">minimum:</span> <span class="mi">6</span> <span class="p">}</span>
  <span class="n">validates</span> <span class="ss">:password_confirmation</span><span class="p">,</span> <span class="ss">presence:</span> <span class="kp">true</span>
<span class="k">end</span>
</pre></div>
</div></div>


<p>ここまで来たら、テストスイートがパスすることを確認しましょう。</p>

<div class="code"><div class="highlight"><pre><span class="gp">$</span> bundle <span class="nb">exec </span>rspec spec/
</pre></div>
</div>




<div class="label" id="sec-creating_a_user"></div>


<h3><a id="sec-6_3_5" href="/chapters/modeling-users.html#sec-creating_a_user" class="heading"><span class="number">6.3.5</span>ユーザーを作成する</a></h3>


<p>以上でUserモデルの基本部分が完了しましたので、今度は<a class="ref" href="/chapters/sign-up.html#sec-showing_users">7.1</a>でユーザー情報表示ページを作成するときに備えて、データベースにユーザーを1人新規で作成しましょう。この作業によって、これまでの節で行なってきた実装が動作することも実感できることでしょう。テストスイートがパスするだけでは味気ないので、実際に開発データベースにユーザーを登録することで喜びを感じていただければと思います。</p>

<p>ただしWebからのユーザー登録はまだできない (完成は<a class="ref" href="/chapters/sign-up.html#top">第7章</a>です) ので、Railsコンソールを使用して手動でユーザーを作成することにしましょう。<a class="ref" href="/chapters/modeling-users.html#sec-creating_user_objects">6.1.3</a>のときとは異なり、今回はサンドボックスで起動する必要は<em>ありません</em>。データベースに実際にレコードを保存しなければ意味がないからです。</p>

<div class="code"><div class="highlight"><pre><span class="go">$ rails console</span>
<span class="gp">&gt;&gt; </span><span class="no">User</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="nb">name</span><span class="p">:</span> <span class="s2">&quot;Michael Hartl&quot;</span><span class="p">,</span> <span class="ss">email:</span> <span class="s2">&quot;mhartl@example.com&quot;</span><span class="p">,</span>
<span class="gp">?</span><span class="gp">&gt; </span>            <span class="ss">password:</span> <span class="s2">&quot;foobar&quot;</span><span class="p">,</span> <span class="ss">password_confirmation:</span> <span class="s2">&quot;foobar&quot;</span><span class="p">)</span>
<span class="go">=&gt; #&lt;User id: 1, name: &quot;Michael Hartl&quot;, email: &quot;mhartl@example.com&quot;,</span>
<span class="go">created_at: &quot;2011-12-07 03:38:14&quot;, updated_at: &quot;2011-12-07 03:38:14&quot;,</span>
<span class="go">password_digest: &quot;$2a$10$P9OnzpdCON80yuMVk3jGr.LMA16VwOExJ...&quot;</span><span class="go">&gt; </span>
</pre></div>
</div>


<p>実際にデータが登録されたことを確認するために、SQLite Database Browserを使用して開発データベース (<code>db/development.sqlite3</code>) の中にある行を見てみましょう (<a class="ref" href="/chapters/modeling-users.html#fig-sqlite_user_row">図6.6</a>)。データモデルの属性に対応するカラムは<a class="ref" href="/chapters/modeling-users.html#fig-user_model_password_digest">図6.5</a>で定義されていることを思い出してください。</p>

<div class="label" id="fig-sqlite_user_row"></div>


<div class="figure"><div class="center"><span class="graphic"><img src="/images/figures/sqlite_user_row_with_password.png" alt="sqlite_user_row_with_password" /></span></div><div class="caption"><span class="header">図6.6</span><span class="description">SQLiteデータベース<code>db/development.sqlite3</code>に登録されたユーザーの行。<a href="http://railstutorial.org/images/figures/sqlite_user_row_with_password-full.png">(拡大)</a></span></div></div>


<p>コンソールに戻って<code>password_digest</code>属性を参照してみると、<a class="ref" href="/chapters/modeling-users.html#code-password_implementation">リスト6.30</a>の<code>has_secure_password</code>の効果を確認できます。</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="n">user</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">find_by_email</span><span class="p">(</span><span class="s2">&quot;mhartl@example.com&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt; </span><span class="n">user</span><span class="o">.</span><span class="n">password_digest</span>
<span class="go">=&gt; &quot;$2a$10$P9OnzpdCON80yuMVk3jGr.LMA16VwOExJgjlw0G4f21yZIMSH/xoy&quot;</span>
</pre></div>
</div>


<p>上の文字列は、パスワード (<code>&quot;foobar&quot;</code>) を暗号化したものであり、ユーザーオブジェクトを初期化するのに使用されました。また、最初に無効なパスワード、次に有効なパスワードを与えることで<code>authenticate</code>の動作を確認することもできます。 </p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="n">user</span><span class="o">.</span><span class="n">authenticate</span><span class="p">(</span><span class="s2">&quot;invalid&quot;</span><span class="p">)</span>
<span class="go">=&gt; false</span>
<span class="gp">&gt;&gt; </span><span class="n">user</span><span class="o">.</span><span class="n">authenticate</span><span class="p">(</span><span class="s2">&quot;foobar&quot;</span><span class="p">)</span>
<span class="go">=&gt; #&lt;User id: 1, name: &quot;Michael Hartl&quot;, email: &quot;mhartl@example.com&quot;,</span>
<span class="go">created_at: &quot;2011-12-07 03:38:14&quot;, updated_at: &quot;2011-12-07 03:38:14&quot;,</span>
<span class="go">password_digest: &quot;$2a$10$P9OnzpdCON80yuMVk3jGr.LMA16VwOExJ...&quot;</span><span class="go">&gt; </span>
</pre></div>
</div>


<p>要求に沿って、<code>authenticate</code>メソッドはパスワードが無効なときは<code>false</code>を返し。パスワードが有効なときはユーザー自身を返しています。</p>

<h2><a id="sec-6_4" href="/chapters/modeling-users.html#sec-6_4" class="heading"><span class="number">6.4</span>最後に</a></h2>


<p>この章では、まったく最初からUserモデルを作成し、それに<code>name</code>属性と<code>email</code>属性を与え、さまざまなパスワード属性も与え、値を制限する多くの重要な検証も追加しました。さらに、与えられたパスワードをセキュアに認証できるようにしました。以前のバージョンのRailsであれば、このような実装を行うためのコードは現在の倍以上になっていたことでしょう。現在はコンパクトな<code>validates</code>メソッドや<code>has_secure_password</code>メソッドがあるおかげで、わずか10行程度のソースコードでUserモデルを完成させることができました。</p>

<p>次の<a class="ref" href="/chapters/sign-up.html#top">第7章</a>では、ユーザーを作成するためのユーザー登録フォームを作成し、各ユーザーの情報を表示するためのページも作成します。<a class="ref" href="/chapters/sign-in-sign-out.html#top">第8章</a>では、<a class="ref" href="/chapters/modeling-users.html#sec-adding_a_secure_password">6.3</a>の認証システムを利用して、ユーザーが実際にWebサイトにサインインできるようにします。</p>

<p>Gitを使用している方は、しばらくコミットしていなかったのであれば、この時点でコミットしておくのがよいでしょう。</p>

<div class="code"><div class="highlight"><pre><span class="gp">$</span> git add .
<span class="gp">$</span> git commit -m <span class="s2">&quot;Make a basic User model (including secure passwords)&quot;</span>
</pre></div>
</div>


<p>次にmasterブランチにマージバックします。</p>

<div class="code"><div class="highlight"><pre><span class="gp">$</span> git checkout master
<span class="gp">$</span> git merge modeling-users
</pre></div>
</div>


<h2><a id="sec-6_5" href="/chapters/modeling-users.html#sec-6_5" class="heading"><span class="number">6.5</span>演習</a></h2>




<ol>

<li><a class="ref" href="/chapters/modeling-users.html#code-email_downcase">リスト6.23</a>の、メールアドレスを小文字に変換するコードに対するテストを、<a class="ref" href="/chapters/modeling-users.html#code-email_downcase_test">リスト6.31</a>のように作成してください。<code>before_save</code>の行をコメントアウトすることで、<a class="ref" href="/chapters/modeling-users.html#code-email_downcase_test">リスト6.31</a>が正しい対象をテストしていることを確認してください。</li>

<li><code>before_save</code>コールバックを<a class="ref" href="/chapters/modeling-users.html#code-downcase_bang">リスト6.32</a>のように書いてもよいことを、テストスイートを実行して確認してください。</li>

<li>Rails APIサイトの<code>ActiveRecord::Base</code>の項を読み通し、どんなことができるかを把握してください。</li>
<li>Rails APIサイトで<code>validates</code>メソッドを調べ、どんなことができるか、どんなオプションがあるかを調べてください。</li>
<li><a href="http://www.rubular.com/">Rubular</a>で数時間ほど遊んでみてください。</li>

</ol>




<div class="label" id="code-email_downcase_test"></div>


<div class="codelisting">
<div class="listing"><span class="header">リスト6.31</span> <span class="description"><a class="ref" href="/chapters/modeling-users.html#code-email_downcase">リスト6.23</a>のメールアドレス小文字変換をテストする。</span><br /><span class="description"> <code>spec/models/user_spec.rb</code></span> </div>
<div class="code"><div class="highlight"><pre><span class="nb">require</span> <span class="s1">&#39;spec_helper&#39;</span>

<span class="n">describe</span> <span class="no">User</span> <span class="k">do</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="n">describe</span> <span class="s2">&quot;email address with mixed case&quot;</span> <span class="k">do</span>
    <span class="n">let</span><span class="p">(</span><span class="ss">:mixed_case_email</span><span class="p">)</span> <span class="p">{</span> <span class="s2">&quot;Foo@ExAMPle.</span><span class="s2">CoM&quot;</span> <span class="p">}</span>

    <span class="n">it</span> <span class="s2">&quot;should be saved as all lower-case&quot;</span> <span class="k">do</span>
      <span class="vi">@user</span><span class="o">.</span><span class="n">email</span> <span class="o">=</span> <span class="n">mixed_case_email</span>
      <span class="vi">@user</span><span class="o">.</span><span class="n">save</span>
      <span class="vi">@user</span><span class="o">.</span><span class="n">reload</span><span class="o">.</span><span class="n">email</span><span class="o">.</span><span class="n">should</span> <span class="o">==</span> <span class="n">mixed_case_email</span><span class="o">.</span><span class="n">downcase</span>
    <span class="k">end</span>
  <span class="k">end</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
<span class="k">end</span>
</pre></div>
</div></div>




<div class="label" id="code-downcase_bang"></div>


<div class="codelisting">
<div class="listing"><span class="header">リスト6.32</span> <span class="description"><code>before_save</code>コールバックの別の実装。</span><br /><span class="description"> <code>app/models/user.rb</code></span> </div>
<div class="code"><div class="highlight"><pre><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="ss">ActiveRecord::Base</span> 
  <span class="n">attr_accessible</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">:email</span><span class="p">,</span> <span class="ss">:password</span><span class="p">,</span> <span class="ss">:password_confirmation</span>
  <span class="n">has_secure_password</span>

  <span class="n">before_save</span> <span class="p">{</span> <span class="n">email</span><span class="o">.</span><span class="n">downcase!</span> <span class="p">}</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
<span class="k">end</span>
</pre></div>
</div></div>


<div class="navigation">  <a class="prev_page" href="/chapters/filling-in-the-layout.html#top">
</a><a class="prev_page" href="/chapters/filling-in-the-layout.html#top"><span class="number">第5章</span>レイアウトを作成する</a><a class="prev_page" href="/chapters/filling-in-the-layout.html#top">  </a>
  <a class="next_page" href="/chapters/sign-up.html#top">
</a><a class="next_page" href="/chapters/sign-up.html#top">    <span class="number">第7章</span>ユーザー登録</a><a class="next_page" href="/chapters/sign-up.html#top">  </a>
</div><div class="footnotes">
<ol>
<li id="fn-6_1">この名前の由来は “<a href="http://en.wikipedia.org/wiki/Active_record_pattern">active record pattern</a>” です。Martin Fowler著「<em>エンタープライズ アプリケーションアーキテクチャパターン </em>」で特定および命名されました。<a class="arrow" href="/chapters/modeling-users.html#fnref-6_1">↑</a></li>
<li id="fn-6_2">「エスキューエル」と発音しますが、「スィークゥエル」もよく使われます。<a class="arrow" href="/chapters/modeling-users.html#fnref-6_2">↑</a></li>
<li id="fn-6_3">メールアドレスをユーザー名にしたことで、理屈の上では将来ユーザー同士で通信できるように拡張できる可能性が開かれます。<a class="arrow" href="/chapters/modeling-users.html#fnref-6_3">↑</a></li>
<li id="fn-6_4"><code>t</code>オブジェクトが具体的に何をしているのかを正確に知る必要はありませんので、どうか心配しないでください。<em>抽象化レイヤ</em>の素晴らしい点は、それが何であるかを知る必要がないという点です。安心して<code>t</code>オブジェクトに仕事を任せればよいのです。<a class="arrow" href="/chapters/modeling-users.html#fnref-6_4">↑</a></li>
<li id="fn-6_5">公式には「エスキューエライト」と発音しますが、(本来は誤りとされている)「スィークゥエライト」もよく使われています。<a class="arrow" href="/chapters/modeling-users.html#fnref-6_5">↑</a></li>
<li id="fn-6_6"><code>&quot;2011-12-05 00:57:46&quot;</code>というタイムスタンプが気になった方もいると思いますが、著者はこの箇所を真夜中過ぎに書いたわけではありません。実はこのタイムスタンプは<a href="http://en.wikipedia.org/wiki/Coordinated_Universal_Time">協定世界時</a> (UTC) に合わせてあります。これは<a href="http://en.wikipedia.org/wiki/Greenwich_Mean_Time">グリニッジ標準時</a> (GMT) と同様、標準時間として使用されます。「<a href="http://tf.nist.gov/general/misc.htm">NIST時刻と周波数FAQ</a>」によると、<strong>問:</strong> 協定世界時 (Coordinated Universal Time) の略称がCUTではなくUTCなのはなぜですか。<strong>答え:</strong> 協定世界時システムは、1970年に国際電気通信連合 (ITU) の技術専門家の国際諮問グループによって考案されました。このときITUは、混乱を最小限にとどめるために、略称を1つだけにしたいと考えました。このとき、英語式のCUTもフランス式のTUCも満場一致とならず、両者の妥協案としてUTCという略語が採用されました。<a class="arrow" href="/chapters/modeling-users.html#fnref-6_6">↑</a></li>
<li id="fn-6_7"><code>user.updated_at</code>の値にご注目ください。上の脚注にも書いたとおり、このタイムスタンプはUTCベースです。<a class="arrow" href="/chapters/modeling-users.html#fnref-6_7">↑</a></li>
<li id="fn-6_8">例外と例外ハンドリングは、ある意味でRubyの高度なテーマです。本書では例外についてこれ以上言及しません。しかし例外が重要なものであることも確かなので、<a class="ref" href="/chapters/beginning.html#sec-comments_for_various_readers">1.1.1</a>で推薦したRuby本で例外について詳しく学ぶことをお勧めします。<a class="arrow" href="/chapters/modeling-users.html#fnref-6_8">↑</a></li>
<li id="fn-6_9">今後、コンソールコマンドの出力は、特に教育的効果が高いと思える場合 (ここでの<code>User.new</code>の場合など) を除いて省略いたします。<a class="arrow" href="/chapters/modeling-users.html#fnref-6_9">↑</a></li>
<li id="fn-6_10"><a class="ref" href="/chapters/modeling-users.html#table-valid_email_regex">表6.1</a>の正規表現の説明における「文字」は、実は「小文字のみ」が対象になっていることにご注意ください。ただし、正規表現の末尾に<code>i</code>オプションを追加してあるので、大文字小文字が区別されずにマッチするようになっています。<a class="arrow" href="/chapters/modeling-users.html#fnref-6_10">↑</a></li>
<li id="fn-6_11">著者同様このツールを便利だと思ってくださる方は、<a href="http://lovitt.net/">Michael Lovitt</a>の素晴らしい成果に報いるために、どうか<a href="http://bit.ly/donate-to-rubular">Rubularへの寄付</a>をお願いいたします。<a class="arrow" href="/chapters/modeling-users.html#fnref-6_11">↑</a></li>
<li id="fn-6_12">驚いたことに、公式標準によると<code>&quot;Michael Hartl&quot;@example.com</code>のようなクォートとスペースを使用したメールアドレスも有効なのだそうです。まったく馬鹿げています。今あなたが使用しているメールアドレスが、英文字、数字、アンダースコア、ドット以外の文字を含んでいるのであれば、そういう文字を含まないメールアドレスに変えることをお勧めします。ただしここで注意すべきことがあります。<a class="ref" href="/chapters/modeling-users.html#code-validates_format_of_email">リスト6.17</a>の正規表現では、プラス記号の使用を許していることにご注目ください。これは、Gmail (他のメールサービスにもあるかもしれません) ではプラス記号を使用すると便利なことがあるためです。Gmailでは、example.comからのメールをフィルタするために<tt>username+example@gmail.com</tt>を使用することができます。こうすると、Gmailの<tt>username@gmail.com</tt>というアドレスに転送され、<tt>example</tt>という文字をフィルタできるようになります。<a class="arrow" href="/chapters/modeling-users.html#fnref-6_12">↑</a></li>
<li id="fn-6_13">この節の冒頭で簡単に紹介したように、この目的に使用できる専用のテストデータベース<code>db/test.sqlite3</code>があります。<a class="arrow" href="/chapters/modeling-users.html#fnref-6_13">↑</a></li>
<li id="fn-6_14">技術的には、メールアドレスのうちドメイン名部分だけが (本当は) 大文字小文字を区別しません。foo@bar.comは、本来はdifferent from Foo@bar.comとは別のアドレスです。ただし現実的には、<a href="http://email.about.com/od/emailbehindthescenes/f/email_case_sens.htm">about.com</a>でも指摘されているように、メールアドレスの大文字小文字を区別することを前提にするのはまずい方法です。「メールアドレスの大文字小文字を区別すると、果てしない混乱と相互運用性の問題とひどい頭痛が発生する。メールアドレスの入力時に大文字小文字の区別を要求するのは賢い方法とは言えない。現実には、メールアドレスの大文字小文字の区別を強制するメールサービスやISPはめったに存在しない。メールアドレスのすべての文字を大文字にするなど、受信者のメールアドレスが誤って入力されていれば、メールは返送されるだけだ。」Riley Mosesによるご指摘に感謝いたします。<a class="arrow" href="/chapters/modeling-users.html#fnref-6_14">↑</a></li>
<li id="fn-6_15">もちろん、<a class="ref" href="/chapters/modeling-users.html#code-users_migration">リスト6.2</a>の<code>users</code>テーブル用のマイグレーションファイルを単に編集することも可能なのですが、その場合ロールバックが必要となり、マイグレーションが戻ってしまいます。データモデルの変更が必要になったらその都度マイグレーションを行うのがRails流です。<a class="arrow" href="/chapters/modeling-users.html#fnref-6_15">↑</a></li>
<li id="fn-6_16">著者のシステム上のSQLiteとHeroku上のPostgreSQLで直接実験してみたところ、この手順は実際に必要であることがわかりました。<a class="arrow" href="/chapters/modeling-users.html#fnref-6_16">↑</a></li>
<li id="fn-6_17">http://railstutorial.org/book?version=3.0 <a class="arrow" href="/chapters/modeling-users.html#fnref-6_17">↑</a></li>
</ol>
</div>




